#+TITLE:    "Learn APL" Notes
#+AUTHOR:   Lucas Vieira
#+EMAIL:    lucasvieira@protonmail.com
#+PROPERTY: header-args :tangle learn-apl.apl
#+OPTIONS:  title:t toc:t
#+LANGUAGE: en-us
#+STARTUP:  content

* Getting Started
** Startup

This file follows the [[https://aplwiki.com/LearnApl/TutorialContents][APL tutorial at APL Wiki]].

Also see the [[https://www.gnu.org/software/apl/apl.html][GNU APL Manual]].

Let's make sure our file executes. Executing the tangled file will run
everything done in the tutorial.

Also, for live interaction, use =gnu-apl-interactive-send-*=.

#+begin_src gnu-apl
#!/usr/bin/apl --id 1010
#+end_src

Oh, and just so you know, use a unicode font which supports this stuff.

** Simple arithmetic

Use =⍝= at the beginning of any comment.

#+begin_src gnu-apl
⍝⍝⍝ Getting started

⍝⍝ This is a comment.
⍝⍝ Check the GNU APL keyboard for shortcut hints
⍝⍝ at any time.

⍝ Simple Arithmetic
#+end_src

*** Arithmetic functions

#+begin_src gnu-apl
5+12

18÷3
108÷11

4×7
3.893×7.6
#+end_src

Use =-= for subtraction, and =¯= for negative signal.

#+begin_src gnu-apl
100-95
8-16
#+end_src

*** Arithmetic on lists of numbers

#+begin_src gnu-apl
3+2 4 11 7 5
#+end_src

Spot the difference on applying a sum to each element and applying a
sum on two numbers:

#+begin_src gnu-apl
1+2 3 4
1+234
#+end_src

Lists can be on either side of the sign.

#+begin_src gnu-apl
6 3 8 1+3
2.5 33.7 12 8÷15
9.8 11.2 17 1.2×1.175
#+end_src

It is possible to perform arithmetic between two lists in a
per-element basis, but only if their length matches.

#+begin_src gnu-apl
12 3 29 4×1 3 5 2
#+end_src

*** Order of execution

APL runs stuff from right to left, since there are so many functions
on the language.

#+begin_src gnu-apl
3×3-1
#+end_src

That is because APL groups things from right to left as well.

#+begin_src gnu-apl
2 3 1+8÷2 2 2
#+end_src

If you need to make things unambiguous, use parentheses.

#+begin_src gnu-apl
(2 3 1+8)÷2 2 2
#+end_src

Remember again the difference between =-= and =¯=!

#+begin_src gnu-apl
1985 - 1066       ⍝ Difference of two numbers
3 ¯1 ¯7 + ¯4 ¯1 2 ⍝ Sum between two lists with negative numbers

2-3+5             ⍝ This does 3+5, then does 2-8
2 ¯3+5            ⍝ This adds 5 to the number list 2 ¯3
#+end_src

*** Dual-purpose functions

Some functions can be used for more than one purpose.

When used in infix notation, ordinary operations have their intended
effect:

#+begin_src gnu-apl
5+4
1 3 4+3 1 6
#+end_src

You can, however, use the functions in prefix notation, which will
change their effect.

=+= appears to do nothing. Its true usage happens for assignment, which
we'll see next.

#+begin_src gnu-apl
+12
#+end_src

=-= inverts the signal of al numbers on the list.

#+begin_src gnu-apl
- 3 ¯6 ¯8 4 12 ¯9
#+end_src

=÷= takes the reciprocal of all numbers (divides 1 by them).

#+begin_src gnu-apl
÷1 2 4 10 100
#+end_src

=×= takes the sign of each number from the list. Yields =1= for positive
numbers, =¯1= for negative, and =0= for zero.

#+begin_src gnu-apl
×8 0 ¯3 ¯7 0 4
#+end_src

There is no definition for postfix operators; that would be a syntax
error.

*** Ceiling and floor

- =⌈= rounds a number up;
- =⌊= rounds a number down.

To perform accurate rounding, you may want to use one of the following
patterns:

#+begin_src gnu-apl
⌈120.11 12.32 65.01 13.52 - 0.5
⌊99.99 12.82 15.39 48.90 + 0.5
#+end_src

When using those operators under an infix form, =⌈= selects the greatest
number, while =⌊= selects the smallest number.

#+begin_src gnu-apl
2 ⌈ 6
2 ⌊ 6
#+end_src

One can also use these operations to perform comparisions between
lists of numbers.

#+begin_src gnu-apl
6 8 1 ⌈ 3 5 9
6 8 1 ⌊ 3 5 9
#+end_src

*** Ending a session

If you want to end a session, use

#+begin_src gnu-apl :tangle no
)OFF
#+end_src

This will not be tangled.

*** Exercises

#+begin_src gnu-apl
⍝ Exercises
#+end_src

**** Q1

Enter statements to:

- Multiply each of three numbers, =3 6 2= by =8= and then add =4= to the
  results of the multiplication.

#+begin_src gnu-apl
4 + 8 × 3 6 2
#+end_src

- Add 15% to each number in the list =14 5 78 145=.

#+begin_src gnu-apl
1.15 × 14 5 78 145
#+end_src

- Add the difference between =13= and =8= to =4 6 12 7=.

#+begin_src gnu-apl
(13 - 8) + 4 6 12 7
⍝ Or...
4 6 12 7 + 13 - 8
#+end_src

- Multiply the result of =6= times =3= by the result of =4= times =8= and
  subtract =5= from the total.

#+begin_src gnu-apl
((6 × 3) × (4 × 8)) - 5
⍝ Or...
¯5+(6×3)×4×8
#+end_src

- Reverse the signs in this list: =3 ¯4 ¯12 6=

#+begin_src gnu-apl
- 3 ¯4 ¯12 6
#+end_src

- Compare these lists, selecting the larger number in each
  comparision:
  - =2 7 0 55=
  - =33 1 10 13=

#+begin_src gnu-apl
2 7 0 55 ⌈ 33 1 10 13
#+end_src

**** Q2

Which of these statements cause error messages? Why?

- Statement =a= is a valid multiplication between =12= and =9=.
- Statement =b= is a valid sum between =3= and =¯2=.
- Statement =c= produces a =LENGTH ERROR= because =19 0 3 4= and =7 2 87= are
  lists of different lengths.
- =5 ¯8= is a valid list of two numbers; it may be unintended, though.

**** Q3 

You're getting =£200= worth of dollars for yourself and =£180= and =£230=
worth respectively for two friends. Enter a statement which calculates
how many dollars each of you will get at =1.96= dollars to the pound.

#+begin_src gnu-apl
200 180 230×1.96
#+end_src

**** Q4

Highest recorded temperatures for a week in August were:

- =79 84 83 78 74 69 70= (Fahrenheit)

Enter a statement to convert them into Centigrade. (One method is to
subtract 32 degrees and multiply by 5/9.) Suppress decimal places in
the result.

#+begin_src gnu-apl
⌊((79 84 83 78 74 69 70-32)×5÷9)+0.5
⍝ Or...
⌈¯0.5+(5÷9)×79 84 83 78 74 69 70-32
#+end_src

**** Q5

Enter a statement to find the difference in metres between 1500 metres
and a mile. (1 yard = 0.9144m and 1760 yards in a mile)

#+begin_src gnu-apl
¯1500+1760×0.9144
#+end_src

** Variables

#+begin_src gnu-apl
⍝ Variables
#+end_src

*** Assignments

An assignment can be done with a variable name and a =←= symbol.

#+begin_src gnu-apl
A ← .175
#+end_src

This enables =A= to be used in expressions.

#+begin_src gnu-apl
200×A
A×30.50 12.25 60.30 15.00
⌈ A×30.50 12.25 60.30 15.00
#+end_src

=C= is the conversion factor for fonverting pounds to kilograms.

#+begin_src gnu-apl
C ← .45359237
17 × C        ⍝ Convert 17 lbs into Kg
⌈C×11×14      ⍝ How many Kgs are there in 11 stones,
              ⍝ then round up
#+end_src

To keep a calculation, we then use variables.

#+begin_src gnu-apl
JOE ← ⌈C×11×14
#+end_src

*** Variable names

Valid statements:

#+begin_src gnu-apl
AAA ← 4
ab ← 1
C9999 ← 0
Jack_Smith ← 100
#+end_src

Which denotes that APL is case sensitive.

Also, APL doesn't have bare words as variable names:

#+begin_src gnu-apl :tangle no
JOHN SMITH ← 100
#+end_src

However, using parentheses will create two identical variables with
the same value. This happens in both GNU APL and Dyalog.

#+begin_src gnu-apl :tangle no
(JOHN SMITH) ← 100 ⍝ Creates JOHN with value 100
                   ⍝ and SMITH with value 100
#+end_src

And if you start a variable name with a single number, the number will
be printed right after the value, which is assigned to the variable
name that follows:

#+begin_src gnu-apl :tangle no
5B ← 12
#+end_src

*** Assigning lists to variables

#+begin_src gnu-apl
PRICE ← 12.45 5.60 5.99 7.75
+VAT   ← PRICE × A ⍝ A was assigned earlier
#+end_src

The =+= operator, when put before an assignment, forces a declarative
behaviour on the assigned variable -- in other words, forces the
variable to be displayed.

Using an unassigned variable causes a =VALUE ERROR=.

*** System commands

The =)OFF= command has already been presented earlier.

=)VARS= lists all variables in the workspace.

#+begin_src gnu-apl
)VARS
#+end_src

=)WSID= shows the identity of the current workspace, which defaults to
=CLEAR WS=.

#+begin_src gnu-apl
)WSID
#+end_src

This command can also be used to change the identity of the
workspace; we change its name to =NEW=. The variables in it won't
change.

#+begin_src gnu-apl
)WSID NEW
#+end_src

To remove the variables (and the name), we can use =)CLEAR=.

#+begin_src gnu-apl
)CLEAR
#+end_src

*** Character assignments

APL doesn't only deals with numbers, it can also deal with text. Just
apply quotes.

#+begin_src gnu-apl
A ← 'APL WILL PROCESS TEXT'
C ← 'CHARACTERS'
#+end_src

To insert quotes inside the text, use =''=.

#+begin_src gnu-apl
NAME ← 'WHAT''S IN A NAME? '
#+end_src

Other way to do that is by using double quotes around the characters.

#+begin_src gnu-apl :tangle no
NAME ← "WHAT'S IN A NAME? "
#+end_src

Consider the following variables.

#+begin_src gnu-apl
N ← 'NET PRICE'
QTY ← '230'
#+end_src

Attempting to perform arithmetic on text generates a =DOMAIN ERROR=:

#+begin_src gnu-apl :tangle no
N×10
QTY+5
#+end_src

*** Multiple assignments

One can assign one value to multiple variables at the same time:

#+begin_src gnu-apl
(ZAK YAK) ← 5
#+end_src

Or assign many values to many variables at the same time too:

#+begin_src gnu-apl
(YEN MARK BUCK) ← 10 20 30
#+end_src

*** Displaying variables together

This part is straightforward.

#+begin_src gnu-apl
N 10
NAME C

X ← 18
Y ← 3 1985
X Y

NAME X C

'NET PRICE: ' 10
#+end_src

*** Joining lists

When writing =X Y=, these values were joined in a list of two
elements. The first element was the number in =X=, the second was the
two-element list in =Y=.

Let's store this result.

#+begin_src gnu-apl
Z ← X Y
#+end_src

Operations done in =Z= will not affect =X= and =Y= (also notice how =+10= maps
elegantly into sublists!!!):

#+begin_src gnu-apl
Z ← Z+10
#+end_src

Example with characters.

#+begin_src gnu-apl
CNAME ← 'BASIL '
SNAME ← 'BRUSH'
NAME  ← CNAME SNAME
#+end_src

Notice, though, that =NAME= is a list of two elements, each being a list
of characters; this is called a /nested variable/.

**** Extra stuff

This was learned from experimentation:

The operator =⍴= (rho) gives us the number of elements in a nested
variable, when used in prefix form.

In its infix form, =⍴= takes a number (left) of elements from the nested
variable (right).

#+begin_src gnu-apl
⍴NAME
1⍴NAME
#+end_src

*** Joining and merging variables

The comma (=,=) allows APL to catenate lists.

#+begin_src gnu-apl
NAME ← CNAME,SNAME
#+end_src

One can see that the variable indeed became a non-nested list of 11
characters.

#+begin_src gnu-apl
⍴NAME
#+end_src

*** Simple and nested variables

Single numbers (separated by spaces) and characters make up lists.

#+begin_src gnu-apl
PIERRE ← 1 2 3 4
MIREILLE ← 'FILLE'
#+end_src

Numbers enclosed in parentheses are treated as single items, so now
=PIERRE= will be a list, containing two lists.

#+begin_src gnu-apl
PIERRE ← (1 2 3) (4 5 6 7)
#+end_src

A list of character lists is easier, just enclose each sublist in
quotes (if you were to put it in a single, simple list, you'd put
everyone under the same quotes anyway):

#+begin_src gnu-apl
FRANCOISE ← 'UNE' 'JEUNE' 'FILLE'
#+end_src

*** Mixed variables

This is not good for arithmetic, but it's useful to store characters
and numbers together.

#+begin_src gnu-apl
PHONES ← 'BILL' 577332 'FRANK' 886331
#+end_src

*** Exercises

Let's start with a clean workspace.

#+begin_src gnu-apl
)CLEAR
#+end_src

**** Q1

Enter statements which:

- Assign the numbers =22 2 2007= to three variables called respectively
  =D=, =M= and =Y=.

#+begin_src gnu-apl
(D M Y) ← 22 2 2007
#+end_src

- Assign the characters =TODAY'S DATE:= to a variable called =DATE=.

#+begin_src gnu-apl
DATE ← 'TODAY''S DATE: '
#+end_src

- Produce the display: =TODAY'S DATE: 22 2 2007=

#+begin_src gnu-apl
DATE D M Y
#+end_src

**** Q2

Set up a variable =CONV= which contains a constant for converting pounds
to kilos. (1lb = 0.454Kg and 14lb = 1 stone). Use =CONV= to convert your
weight (to the nearest stone) into kilograms. Reduce the result by
10%, round it down, and display it.

#+begin_src gnu-apl
⍝ 1 stone = 14 lbs.
⍝ 1 lb    = 0.454 Kg.
⍝ Let's pretend I weight 11.5 stones.
CONV     ← .454
MYWEIGHT ← ⌊11.5×CONV×14×.9
MYWEIGHT
#+end_src

**** Q3

The cost prices of four items of stock are £8, 6, 12, 4
respectively. The markup on these items is 100%. Three other items
cost respectively £16, 13 and 7. Their markup is 75%. Calculate the
fully inclusive price of each item (with VAT at 17%). Display the
prices (rounded up) with the caption: ='PRICE+VAT: '=

#+begin_src gnu-apl
ITEMS_A ← 2×8 6 12 4
ITEMS_B ← 1.75×16 13 7
ITEMS   ← ⌈1.17×ITEMS_A,ITEMS_B
'PRICE+VAT: ' ITEMS
#+end_src

**** Q4

=TEST1= contains a student's exam marks for each of seven subjects (65
72 54 80 67 60 59). =TEST2= contains his marks for the same subjects
gained at a different test (75 70 60 74 58 61 50). Produce a list
consisting of his higher mark for each subject.

#+begin_src gnu-apl
TEST1 ← 65 72 54 80 67 60 59
TEST2 ← 75 70 60 74 58 61 50
TEST1 ⌈ TEST2
#+end_src

**** Q5

Which of the following will produce error messages? Why?

- The expression =RATE ← '3.7×3'= is a valid assignment of a list of
  characters, though it might be a logic error.
- The expression =10+10 '←21'= produces a =DOMAIN ERROR=, because it tries
  to sum =10= over a list containing the number =10= and the list of
  characters ='←21'=, which cannot perform arithmetic operations.
- The expression =100×RATE= produces a =DOMAIN ERROR=, because it tries to
  multiply by =100= over a list containing characters (=RATE=), which
  cannot perform arithmetic operations.
- The expression =SYMBOLS ← '¯<≤=≥'= is perfectly valid and creates a
  list of characters. But it might not be supported by some APL
  implementations (GNU APL supports it).
- The expression =3+'232'= produces a =DOMAIN ERROR=, because it tries to
  sum =3= over a list of characters, which cannot perform arithmetic
  operations.

*** Cleanup

From now on, we clear the variables and the workspace across chapters.

#+begin_src gnu-apl
)CLEAR
#+end_src

** Tables

We won't be typing a lot of things here, that is insane! Let's see how
to generate our tables.

#+begin_src gnu-apl
⍝ Tables
#+end_src

*** The Roll function

=?= is the Roll function, also called Random or Deal.

This generates numbers on range 1 to 100:

#+begin_src gnu-apl
? 100
#+end_src

The two-argument form generates a list of =n= (left) *unique* numbers from
1 to =m= (right):

#+begin_src gnu-apl
50 ? 100
#+end_src

In fact, it should always be true that =n ≤ m=, since the generated
numbers are unique. If not, we'll have a =DOMAIN ERROR=.

Both =n= and =m= can be replaced by variables as well.

*** The Iota function

Iota, or Index, generates a sequence of numbers from 1 to =m= in its
one-argument form.

#+begin_src gnu-apl
⍳100
#+end_src

*** Setting up tables

When entering tables, we use dyadic for of the rho (=⍴=) function, also
called Shape or Reshape. The list before =⍴= states the order of the
table; the following elements are its rows, element by element.

#+begin_src gnu-apl
4 3 ⍴ 10 20 30 40 50 60 70 80 90 100 110 120
#+end_src

Let's generate twelve random numbers, then display them in a 4×3
table.

#+begin_src gnu-apl
DATA ← 12 ? 100
4 3 ⍴ DATA
#+end_src

If you feed =⍴= less numbers than expected, APL just keeps wrapping
these numbers. If you feed more than expected, APL uses just enough
numbers to build the table.

#+begin_src gnu-apl
4 3 ⍴ 1 2 3 4 5
#+end_src

And so follows that supplying one number fills the whole table:

#+begin_src gnu-apl
3 5 ⍴ 1
#+end_src

**** Extra bit

I wonder about identity matrices! Let's take a 3×3 matrix. If we type
a =1=, and then a number =n= of zeroes (corresponding to the matrix
order), then I suppose we can build an identity matrix...

#+begin_src gnu-apl
3 3 ⍴ 1 0 0 0
#+end_src

Indeed! But wait: I don't know how to build functions in APL yet, but
I suppose we can take this arbitrary number of zeroes and write them
in ⍴-notation too.

- Generate a list of =n= zeroes;
- Catenate a number =1= in front of it;
- Feed it as filling elements to the second ⍴.

#+begin_src gnu-apl
4 4 ⍴ 1,(4 ⍴ 0)
#+end_src

*** Arithmetic on tables

Let's begin.

#+begin_src gnu-apl
SALES ← 3 3⍴20 13 8 30 43 48 3 50 21
SALES
#+end_src

Performing arithmetic on a table affects every number, just like in a
list.

#+begin_src gnu-apl
SALES×10
#+end_src

Let's set up another table.

#+begin_src gnu-apl
PRICES ← 2 3 ⍴ 21 2 12 47 33 1
#+end_src

This operation causes a =LENGTH ERROR=:

#+begin_src gnu-apl :tangle no
SALES×PRICES
#+end_src

This is because =SALES= is 3×3 while =PRICES= is 2×3. So let's reshape
=SALES= into a 3×2 table. This way, both of them will have the same
number of elements.

#+begin_src gnu-apl
SALES ← 3 2⍴SALES
#+end_src

But that still won't do... we're trying to multiply elements of same
address here, not make matrix multiplication. Let's try again.

#+begin_src gnu-apl
SALES ← 2 3⍴SALES
#+end_src

Ok, now we're good and we can proceed.

#+begin_src gnu-apl
TOTAL ← SALES×PRICES
SALES-PRICES
#+end_src

**** Extra bits

Let's build a nice table.

First table:
- Build a sequence from =1= to =25=.
- Create a =5×5= table with it.
- Take the reciprocal of each number.
- Multiply each element by =10=.

Second table:
- Take a sequence from =1= to =25=.
- Add =25= to each element.
- Create a =5×5= table with it.

Final table:
- Multiply each element of first table by each element of second
  table.
- Round every number by adding =¯.5= to each number and taking their
  ceiling.

#+begin_src gnu-apl
TOTAL ← ⌈¯.5+(5 5⍴25+⍳25)×10×÷5 5⍴⍳25
#+end_src

*** Catenating tables

Catenating tables produce a big table. Each row is catenated like a
list. Therefore, catenated tables must have the same number of rows.

#+begin_src gnu-apl
SALES,PRICES
#+end_src

Let's test it a little more.

#+begin_src gnu-apl
LITTLE ← 2 2⍴1
MEDIUM ← 2 6⍴5
BIG    ← LITTLE,MEDIUM
#+end_src

To perform =LITTLE+MEDIUM=, we pad =LITTLE= with a table of zeroes.

#+begin_src gnu-apl
ZEROES ← 2 4⍴0
LITTLE ← LITTLE,ZEROES
LITTLE+MEDIUM
#+end_src

We could also have the zeroes on the other side; let's reset =LITTLE=
and do it.

#+begin_src gnu-apl
LITTLE ← 2 2⍴1
LITTLE ← ZEROES,LITTLE
LITTLE+MEDIUM
#+end_src

Since there is this kind of ambiguity, that is the reason why APL
doesn't do arithmetic on data of unequal size.

*** Selecting elements

Let's set up a =4×3= table for the next example.

#+begin_src gnu-apl
+TABLE ← 4 3⍴2 12 15 4 11 7 1 16 8 20 19 9
#+end_src

Let's select the =9= in the bottom row, rightmost column.

#+begin_src gnu-apl
TABLE[4;3]
#+end_src

We sum the element at Row 1, Column 2 to the element at Row 2,
Column 2. Then we put it on Row 3, Column 2:

#+begin_src gnu-apl
TABLE[3;2] ← TABLE[1;2] + TABLE[2;2]
#+end_src

We can select more than one element in a row, or even in a column.

#+begin_src gnu-apl
TABLE[1;1 2]
TABLE[1 2;2]
#+end_src

To select entire rows or columns, omit the other parameter.

#+begin_src gnu-apl
TABLE[1;]
TABLE[;1]
#+end_src

Let's replace the numbers in column 3 with the sum of numbers in
columns 1 and 2.

#+begin_src gnu-apl
TABLE[;3] ← TABLE[;1] + TABLE[;2]
#+end_src

Also note that indexing can also be applied on lists.

#+begin_src gnu-apl
LIST ← 8 1 90 4
LIST[2]
#+end_src

*** Dimensions

In APL, data has dimensions.

- Single numbers have dimension zero.
- A list has one dimension.
- The previous tables have two dimensions.
- Three-dimensional tables/arrays are like cubes, having depth, height
  and length.
- It is possible to create arrays of many dimensions in APL.

#+begin_src gnu-apl
SALES ← 6 4⍴24?50
#+end_src

In =SALES=, the salesmen are rows, the products are columns.
If we wanted to represent more than one region -- say, three regions
--, we'd need another dimension.

#+begin_src gnu-apl
+SALES ← 3 6 4⍴72?100
SALES[2;5;4]           ⍝ Plane 2, Row 5, Column 4
SALES[2;;]             ⍝ Plane 2
#+end_src

*** Enquiring about the size of data

While the dyadic usage of =⍴= involves creating arrays, the monadic
usage of =⍴= allows one to enquire about the size (or shape) of existing
tables, variables, etc.

#+begin_src gnu-apl
⍴SALES
#+end_src

Let's create some data.

#+begin_src gnu-apl
TABLE ← 5 3⍴15?20
LIST ← ⍳6
NUM ← 234
#+end_src

Now let's ask about their shape.

#+begin_src gnu-apl
⍴TABLE
⍴LIST
⍴NUM
#+end_src

Notice that, since =NUM= has no shape (equivalent to a point), APL gives
an empty response.

We don't need variables to do this kind of thing, though. We can apply
directly to literals.

#+begin_src gnu-apl
⍴12 61 502 1 26 0 11
⍴'SHAMBOLIOSIS'
#+end_src

*** Tables of characters

This is also straightforward; characters are stored as a list of
characters. Let's do some experiments.

#+begin_src gnu-apl
⍝ Compare these two.
ALF ← 3 5⍴'ABCDE'
NUM ← 3 5⍴12345

MYNAME ← 'GORSUCH'
⍴MYNAME

3 7⍴MYNAME
3 14⍴MYNAME
3 18⍴MYNAME

MYNAME ← 'GORSUCH '
⍴MYNAME

3 40⍴MYNAME
#+end_src

Solution for the given example.

#+begin_src gnu-apl
4 11⍴'ADAMS      CHATER     PRENDERGASTLEE        '
#+end_src

*** Mixed tables

We can build tables containing characters and numbers, just like the
lists.

#+begin_src gnu-apl
MIXTURE ← 3 3⍴'A' 1 'B' 'C' 2 'D' 'E' 3 'F'
#+end_src

**** Extra bits

You can't perform arithmetic in such a table, but you can of course
reshape it to do so. I built an example for that by myself:

#+begin_src gnu-apl
MIXTURE[;2] ← 10×MIXTURE[;2]
#+end_src

*** Nested tables

Tables can contain other tables or lists.

#+begin_src gnu-apl
NEST ← 2 3⍴(2 2⍴⍳4) (⍳5) 'A NAME' (2 4⍴⍳8) 23 (3 4⍴'NAME')
⍴NEST
#+end_src

*** Depth

The depth (=≡=) function shows the degree of nesting in a variable.

#+begin_src gnu-apl
≡45          ⍝ Values have depth 0
≡1 2 3       ⍝ Lists have depth 1
≡2 2⍴3 4 5 6 ⍝ Tables too
#+end_src

Now let's check the depth of =NEST=:

#+begin_src gnu-apl
≡NEST
#+end_src

When at least one element of a list or table is also a list or table,
the depth becomes 2; and so on, as long as you have child list/tables
inside child list/tables:

#+begin_src gnu-apl
BIG_NEST ← NEST NEST
⍴BIG_NEST
≡BIG_NEST
#+end_src

Since the components of =BIG_NEST= already have depth 2, =BIG_NEST= adds
one more layer of depth.

*** Practice

Some interesting snippets showcasing the strength of APL: combining
functions.

#+begin_src gnu-apl
⍝ Playing with sizes of character lists
(⍴'ABC','DEF')+⍴'GHI'

⍝ Selecting the first nine numbers in row 1 of a big table
TABLE ← 10 10⍴100?100
TABLE[1;⍳9]
#+end_src

*** Exercises

#+begin_src gnu-apl
)CLEAR
#+end_src

**** Q1

Set up a four-row one-column table called =MILES= containing =300 42 25
140=.

#+begin_src gnu-apl
MILES ← 4 1⍴300 42 25 140
#+end_src

And a similarly shaped table called =RATES= containing =27.5 15 27.5
27.5=.

#+begin_src gnu-apl
RATES ← 4 1⍴27.5 15 27.5 27.5
#+end_src

Multiply =RATES= by =MILES=, then multiply the result by =0.01= to produce a
table called =EXPENSES=.

#+begin_src gnu-apl
+EXPENSES ← .01×RATES×MILES
#+end_src

**** Q2

Change the number in column 1 row 3 of =MILES= from =25= to =250=. Again,
multiply =RATES= by =MILES= and the result by =0.01= to give =EXPENSES=, then
reformat =EXPENSES= to produce a one-row four-column table.

#+begin_src gnu-apl
MILES[3;1] ← 250
+EXPENSES   ← (.01×RATES×MILES)[;1]
#+end_src

Alternative way to change =EXPENSES=; interesting way to store and
immediately use a variable.

#+begin_src gnu-apl :tangle no
+EXPENSES ← 1 4⍴EXPENSES ← .01×RATES×MILES
#+end_src

**** Q3

Define =X= as a three-row ten-column table containing random numbers,
and =Y= as a three-row four-column table also containing random
numbers. Add =X= to =Y=, first taking whatever steps you think necessary
to enable the operation to take place.

#+begin_src gnu-apl
⍝ Defining the tables
X ← 3 10⍴30?30
Y ← 3 4⍴30+12?12

⍝ To sum Y into X, we catenate zeroes to Y,
⍝ extending it.
X+Y,3 ((⍴X)[2]-(⍴Y)[2])⍴0
#+end_src

Since the problem did not specify where to add the columns, here is an
alternative which catenates the zeroes to the left of =Y=:

#+begin_src gnu-apl :tangle no
X+(3 ((⍴X)[2]-(⍴Y)[2])⍴0),Y
#+end_src

**** Q4

Using table =X=, add the first and second rows and replace the third row
with the result of the addition.

#+begin_src gnu-apl
X[3;] ← X[1;]+X[2;]
#+end_src

**** Q5

Create a table which [displays =APL ROCKS= in vertical orientation]:

#+begin_src gnu-apl
9 1⍴'APL ROCKS'
#+end_src

**** Q6

What will be the result of each of these =⍴= statements? Predict each
result before you press ENTER.

- =⍴'ABC DEF'=\\
  → =7=
- =⍴480 0 1.2=\\
  → =3=
- =TABLE ← 10 10⍴100⍴1000=\\
  =⍴TABLE=\\
  → =10 10=
- =⍴'R'=\\
  → (empty)
- =⍴'480 0 1.2'=\\
  → =9=
- =TABLE ← 2 10 3⍴100⍴100=\\
  =⍴TABLE=\\
  → =2 10 3=

*NOTE:* Recall why =⍴'R'= gives an empty response: a single value is
equivalent to a point, which has no size/dimension/shape.

*** Cleanup

#+begin_src gnu-apl
)CLEAR
#+end_src

** Writing a function

#+begin_src gnu-apl
⍝ Writing a function
#+end_src

*** Precondition: the Slash operator

The Slash (=/=) or Reduce operator is not a function; it modifies or
extends the operation of the functions it is used with.

It works as if by putting the operator between the numbers.

#+begin_src gnu-apl
+/ 1 6 3 4
×/ 1 2 3 4
#+end_src

This can be done on a table too, however it will sum in a row basis.

#+begin_src gnu-apl
TABLE ← 3 3⍴⍳9
TABLE
+/ TABLE
#+end_src

We can, however, apply Reduce twice to obtain the entire sum.

#+begin_src gnu-apl
+/+/ TABLE
#+end_src

Useful combination: To select the largest number in a list, use =⌈=:

#+begin_src gnu-apl
⌈/ 75 72 78 90 69 77 81 88
#+end_src

The opposite equivalent (=⌊=) selects the smallest number:

#+begin_src gnu-apl
⌊/ 75 72 78 90 69 77 81 88
#+end_src

A final example: We take the sum of =X= (which is =15=) and divide it by
=X='s shape (=5=). This yields =3=, as expected of /calculating the average/
of a number.

#+begin_src gnu-apl
X ← ⍳5
(+/ X)÷⍴X
#+end_src

**** Axis arguments

You can apply the Reduce operator on a per-column basis using axis
arguments. For example, these two are equivalent, since they take the
dimension zero (rows):

#+begin_src gnu-apl
+/TABLE
+/[]TABLE
#+end_src

If you wish to use the *columns* instead of the *rows*, just ask for axis
one:

#+begin_src gnu-apl
+/[1]TABLE
#+end_src

*** User functions

Now we'll preserve statements.

It seems some APL editors have a built-in editor. For example, one can
use the following commands:

#+begin_src gnu-apl :tangle no
)EDIT MYFUNC ⍝ On modern editors
)ED MYFUNC   ⍝ On Dyalog
∇            ⍝ On older editors, and on GNU APL as well
#+end_src

GNU APL also calls a new buffer when defining a function, under
Emacs. We can also send the following region to the interpreter no
problem. We just need to type in the function (=∇=) operator, which
starts the input mode.

Typing =∇= again goes back to calculator mode.

#+begin_src gnu-apl
∇TRY1
  'Type some numbers: '
  NUM ← ⎕   ⍝ Asks for user input
  'Total is: ' (+/ NUM)
∇
#+end_src

In case this function doesn't work when typing, just use =∇TRY1= to
change its definition on the editor.

This defines a user function =TRY1=, which takes no arguments. The Quad
(=⎕=) operator calls in for user input.

You can edit a function such as =TRY1= anytime, by typing =∇TRY1= on the
REPL; other APL implementations will allow you to use the command
=)EDIT TRY1=, for example.

Here is another example:

#+begin_src gnu-apl
∇TRY2
  'Type some numbers: '
  NUM ← ⎕
  'You have entered' (⍴NUM) 'numbers'
∇
#+end_src

And as requested, here is a way to calculate the average of some
numbers:

#+begin_src gnu-apl
∇AVERAGE
  'Type some numbers:'
  NUM ← ⎕
  'Integer average of these numbers is:' (⌊(+/ NUM)÷⍴NUM)
∇
#+end_src

One more definition.

#+begin_src gnu-apl
∇TRY3
  'Type some numbers:'
  NUM ← ⎕
  'You have entered' (⍴NUM) 'numbers'
  'The biggest was' (⌈/ NUM)
  'The smallest was' (⌊/ NUM)
  'Sum of numbers is' (+/ NUM)
  'Integer average of numbers is' (⌊(+/ NUM)÷⍴NUM)
∇
#+end_src

*** Saving a workspace

You can check out the user-defined functions in your workspace with
this command:

#+begin_src gnu-apl
)FNS
#+end_src

There are some extra variables as well (check by using =)VARS=), so we
need to erase them:

#+begin_src gnu-apl
)ERASE TABLE X
#+end_src

Now we'll save the current workspace. First let's set the workspace ID
to the filename where it should be salved.

Notice that we are using Unix notation and the XML extension. This is
a requirement for GNU APL.

#+begin_src gnu-apl
)WSID ./MyFirstWS.xml
#+end_src

Windows users, using NARS2000, should do something like:

#+begin_src gnu-apl :tangle no
)WSID 'c:\foo\MyFirstWS'
#+end_src

Now we use the command to save.

#+begin_src gnu-apl
)SAVE
#+end_src

My result was:

#+begin_example
      2019-08-06  12:56:35 (GMT-3) ./MyFirstWS.xml
#+end_example

Now we can safely clear the workspace.

#+begin_src gnu-apl
)CLEAR
#+end_src

To load the workspace again, use the load command with the file name.

#+begin_src gnu-apl
)LOAD ./MyFirstWS.xml
#+end_src

*NOTE:* GNU APL instructs to use =)COPY= instead.

*** User functions with arguments

User functions can have no arguments, one argument or two arguments.

**** Monadic

We intent to build a function which averages the numbers in a list.
So let's define it.

#+begin_src gnu-apl
∇AV X
  (+/ X)÷⍴X
∇
#+end_src

Now we can use it properly.

#+begin_src gnu-apl
AV 12 7 3 1
AV 3 8 1 4
AV 192 4534 12 0 2

NUM ← ⍳5
AV NUM
#+end_src

**** Dyadic

A dyadic function should be declared with arguments to its left and
its right:

#+begin_src gnu-apl
∇A SUM B
  A+B
∇
#+end_src

*** Using function results in other expressions

To do so, we need to rewrite the function to enable that. See this
rewriting of =AV=.

#+begin_src gnu-apl
∇R←AV X
  R←(+/ X)÷⍴X
∇
#+end_src

An example of usage:

#+begin_src gnu-apl
¯3 + AV 3 8 1 4
#+end_src

The same can be done to dyadic functions.

#+begin_src gnu-apl
∇R←A SUM B
  R←A+B
∇
#+end_src

*** Cleanup

#+begin_src gnu-apl
)ERASE NUM
)SAVE
)CLEAR
#+end_src

* APL Concepts
** Overview of the APL System

APL is an interpreted language.

APL reserves an area in the RAM, which is called a workspace. This is
were programs and data reside. Other workspaces can be loaded at will
for calculation and processing.

*** Data

Data is acquired by typing or from files. All data is held in arrays
or scalars.

GNU APL supports complex numbers.

Formal names will be used from now on.

*** Modes

APL uses a modal interpreter. /Calculator mode/ executes statements as
entered. /Definition mode/ does not execute immediately, and stores
statements as a user-defined function or operator. /Function execution
mode/ happens when you run a user-defined function or operator.

*** Built-in functions and operators

APL has about 50 built-in /functions/ which can be invoked by a single
symbol.

Most functions can perform two different opperations depending on
whether they're used with one or two arguments.

APL also has five built-in /operators/. Combining an operator with its
operands creates a /derived function/.

*** System functions and variables

Part of APL system, yet not part of APL language. Used to extend
facilities provided by original APL, they vary from one vendor to
another. Could also be tailored to the system which it is running.

System functions such as =⎕NREAD= and =⎕NWRITE= (with names starting with
a Quad =⎕=) read and write data from files, and are distinguishable from
the rest by their starting character.

*** System commands

They are also not part of the APL language itself, but are crucial to
managing the workspace. They always start with a =)=.

*** User-defined functions and operators

Functions or operators which can be written by the user. Consists of
APL statements that have a name. Functions are edited through the
function editor, which can also be used to tweak a function.

*** Files

Files are usually not necessary on APL, given the convenience of
workspaces, being only really required when dealing with big
projects. When that time comes, APL has facilities for that; and
workspaces can be shared between users.

*** Error handling

APL provides facilities for error trapping and diagnostics.

** The Workspace

Workspaces are containers for functions and data, and can be saved on
disk by using commands.

APL also makes it easy to create test data for functions. Since
prototyping can be done so quickly, APL is sometimes referred to as a
"tool of thought".

*** Functions, operators, classes

/Functions/ can take 0, 1 or 2 arguments; arguments to functions are
always arrays.

/Operators/ look like functions, but takes either one or two operands,
which can be functions (e.g. the Each operator =¨=). They can also be
defined.

/Classes/ are a collection of functions, operators and data (named
properties). Acts as a template to create objects. Classes are
supported in Dyalog, but not in GNU APL.

*** Workspace size

Some APLS allow changing the size of your workspace with =)CLEAR 50MB=,
for example.

To check the amount of free space on your workspace, use the system
function Workspace Available:

#+begin_src gnu-apl
⎕WA
#+end_src

*** Managing the workspace

**** Internal workspace commands

These have already been discussed.

- =)CLEAR=: Clear workspace. Erases all variables, functions, operators
  and classes.
- =)ERASE=: Erases individual classes.
- =)VARS=: Lists all user-defined variables in the workspace.
- =)FNS=: Lists all user-defined functions in the workspace.
- =)OPS=: Lists all user-defined operators in the workspace.
- =)CLASSES=: Lists all user-defined classes in the workspace. Can be
  used in Dyalog.

**** External workspace commands

Some of these have already been discussed.

- =)SAVE myWorkspace= saves a workspace to disk. Append =.xml= if you're
  using GNU APL.
- =)LOAD myWorkspace= loads an entire workspace back into memory; the
  workspace in memory is overwritten.
- =)COPY= can be used to copy a function from a workspace in disk, but
  does not overwrite the current workspace.
- =)DROP= deletes a workspace on disk.
- =)LIB= shows the names of the workspaces stored on disk.

Save locations vary due to APL implementations.

*** System variables

Here are some useful system variables which you may use.

- =⎕WA=: Workspace Available. Number of available bytes for use in
  workspace.
- =⎕PP=: Print Precision. Number of digits displayed in numeric output.
- =⎕PW=: Print Width. Max number of characters in each printed line.
- =⎕LX=: Latent Expression. This variable contains an expression or
  user-defined function which is executed when the workspace is
  loaded; effectively, a setup function for the current
  workspace. Empty by default.
- =⎕IO=: Index Origin. Stores the value where indexes start. GNU APL
  starts at 1, but can be changed to 0.

*** System functions

These vary from vendor to vendor, so there is no guarantee that these
will work in your APL. For example:

- =⎕NL=: Name List. Produces a list of variables, functions, operators
  or classes.
- =⎕EX=: Expunge. Expunges individual APL objects.

System functions are designed to be used in user-defined commands,
whereas system commands are designed for direct usage.

** Data

#+begin_src gnu-apl
⍝⍝⍝ APL Concepts

⍝ Data
#+end_src

*** Variables

Data can be directly quoted...

#+begin_src gnu-apl
234.98×3409÷12.4
#+end_src

...or assigned to a name.

#+begin_src gnu-apl
VAR ← 183.6
#+end_src

*** Names

APL allows uppercase and lowercase characters, some APLs also allows
symbols too.

*** Types of data

Data can be numbers, characters or a mixture of those. GNU APL in
particular also allows complex numbers; Dyalog allows classes.

*** Size, shape and depth

From now on, unless there is something new, only some examples will be
typed.

#+begin_src gnu-apl
⍝ Scalars (no dimensions)
294
'A'

⍝ Vectors (one dimension -- length)
23 8 0 12 3
'ABC'
28 3 'A' 'BC'

⍝ 2D Matrices (two dimensions -- height and length)
⍝ There is no way to write a matrix literal.
4 4⍴7 45 2 89 16 15 10 21 8 0 13 99 83 19 4 27
4 2⍴'WILSO' 393 'ADAMS' 7183 'CAIRN' 87 'SAMSO' 8467

⍝ 3D Matrices (three dimensions)
3 3 4⍴36?100
#+end_src

Arrays are data structures of any dimension -- obviously, scalars do
not apply.

*** Setting up data structures

#+begin_src gnu-apl
X1 ← 23 9 144 12 5 0
X2 ← 1 2 'A' 'B' 3 4
2 3⍴23 9 144 12 5 0

NUMS ← 36?100
3 3 4⍴NUMS

6⍴9

⍝ Nested arrays
VAR ← (2 3⍴9) (1 2 3) 'A' 'ABCD' 88 16.1
#+end_src

*** Data structure /versus/ data value

#+begin_src gnu-apl
X ← 1⍴22
Y ← 22

⍴X    ⍝ 1, because X is a vector
⍴Y    ⍝ Empty response, because Y is a scalar

Z ← 1 5⍴12 5 38 3 6   ⍝ When displayed, Z looks like a vector,
⍴Z                    ⍝ but is in fact a 1×5 matrix

)CLEAR
#+end_src

*** Empty data structures

Useful for some things, for example flor predefined storage areas,
where elements can be added.

#+begin_src gnu-apl
X ← ⍳0   ⍝ X is a vector of zero elements
X        ⍝ Printing X gives an empty response
⍴X       ⍝ Asking for the shape of X gives a zero
#+end_src

This is fundamentally different than a scalar, which does not have
/zero elements/: a scalar has /zero dimensions/ instead.

#+begin_src gnu-apl
⍴45
#+end_src

We can also create empty matrices. For example, a matrix of two rows
and no columns:

#+begin_src gnu-apl
TAB ← 3 0⍴⍳0
TAB
⍴TAB
#+end_src

*** Dimension ordering

General rule when applying an operation to data (e.g. a reduce =/=):

*Unless specified otherwise, the operation takes place on the last
 dimension.*

For example, consider a 3×4 matrix.

#+begin_src gnu-apl
X ← 3 4⍴⍳12
+/ X
#+end_src

Applying a reduction to it yields a list of three elements. Each
element of the list is the sum of a *row*. This is because a column is
the *last* dimension of a 2D matrix (3 rows, 4 columns).

In other words, since we're performing the reduction on the last
dimension (columns), then each result is the sum of all *columns*
belonging to that row.

You can change that by using the axis (=[]=) operator:

#+begin_src gnu-apl
+/[1] X
#+end_src

This carries the reduction on the first axis (rows), therefore the
resulting list of four numbers is the sum of each *column*.

Now each result is the sum of all *rows* belonging to that column.

#+begin_src gnu-apl
)CLEAR
#+end_src

*** Indexing

There is something that remains to be discussed. Last section talked
about the rows in index 1. This seems to mean that in APL indexes
start at 1, but that might not be always true. This is true for GNU
APL, to say the least.

If you wish to change indexing, just change the Index Origin system
variable (this bit is not tangled):

#+begin_src gnu-apl :tangle no
⎕IO ← 0
#+end_src

From here on, we'll consider Index Origin to be =1=.

Selecting elements is easy. Just use the brackets (=[]=), and separate
variable indexes with =;=.

#+begin_src gnu-apl
⍝ Indexing in one dimension
X ← 1 45 6 3 9 33 6 0 1 22
X[4] + X[10]

⍝ Indexing in two dimensions
TABLE ← 3 3⍴9?100
TABLE[3;2]         ⍝ Indexing for more than one dimension

⍝ Indexing in three dimensions
DATA ← 4 4 4⍴64?100
DATA[2;1;4]

⍝ Selecting an entire row in tree ways
TABLE[1;1 2 3]
TABLE[1;⍳3]
TABLE[1;]

⍝ Selecting an entire column
TABLE[;2]

⍝ Selecting from anonymous data
(3 8 4)[1+2]

⍝ Selecting from an anonymous string, based on a variable
P ← 2
'ABCDE'[P]
#+end_src

Some useful stuff that has not been discussed yet:

Indexing can also be used to rearrange elements on a matrix!

#+begin_src gnu-apl
'ABCDE'[4 5 1 4]
#+end_src

We can also do indexing with variables of a higher dimension. This
pretty much collects stuff and stores it in the created shape:

#+begin_src gnu-apl
'ABCDE'[2 2⍴4 5 1 4]
#+end_src

Indexing can also be done with the squad (=⌷=) symbol (notice that this
is different from the quad =⎕=, since it is narrower):

#+begin_src gnu-apl
2⌷'ABCD'
#+end_src

#+begin_src gnu-apl
)CLEAR
#+end_src

** Built-in functions

APL has 50 useful built-in functions in general, and 5 operators to
modify and extend how functions work.

#+begin_src gnu-apl
⍝ Built-in Functions
#+end_src

*** Arguments

Most functions have two behaviours depending on how you place their
arguments. For example:

#+begin_src gnu-apl
⌈12.625         ⍝ Ceiling
2⌈8             ⍝ Select greatest number

÷1 2 3 4 5      ⍝ Reciprocal
100÷1 2 3 4 5   ⍝ Divide 100 by each
#+end_src

*** Execution order

Expressions are evaluated from right to left. The results of one
function become the argument of the next function.

*** Numbers or text

Some functions work on numbers only. Some work on either numbers or
text data. Using a function which does not work on a data type yields
a =DOMAIN ERROR=.

Some functions also work only on a subset of the number domain, such
as logical functions (=∨=, =∧= etc.) Thiis means that they only recognize
the states of TRUTH (=1=) and FALSITY (=0=).

*** Shape and size of data

Some functions can be used only on data of a certain shape. The
following example (not tangled) yields a =LENGTH ERROR=, because data on
both sides do not have the same shape:

#+begin_src gnu-apl :tangle no
29 51 60 27÷3 11
#+end_src

*** Groups of functions

Following there will be some examples of functions, which I'll store
in tables as given in the tutorial, for further consulting.

Unless there is a new function with non-obvious usage, there will be
some examples.

**** Arithmetic functions

|----------+--------------+-------------|
| Function | Monadic form | Dyadic form |
|----------+--------------+-------------|
| +        | Numeric      | Add         |
| -        | Negation     | Subtract    |
| ×        | Sign         | Multiply    |
| ÷        | Reciprocal   | Divide      |
| ⌈        | Ceiling      | Biggest     |
| ⌊        | Floor        | Smallest    |
| \vert        | Modulo       | Remainder   |
|----------+--------------+-------------|

**** Algebraic functions

Functions for advanced arithmetic.

|----------+------------------+---------------------|
| Function | Monadic form     | Dyadic form         |
|----------+------------------+---------------------|
| ⍳        | Index generator  |                     |
| ?        | Random number    | Random deal         |
| ⋆ or *   | 'e' to the power | Number to the power |
| ⍟        | Log to base 'e'  | Log to any base     |
| ○        | \pi times          | Sine, cosine, etc   |
| !        | Factorial        | Combinations        |
| ⌹        | Matrix inversion | Matrix division     |
|----------+------------------+---------------------|

***** Circle operator

The circle operator (=○=) does not have an obvious operation on its
dyadic form. Here is a table of values of \alpha on the case \alpha ○
\omega, taken from TryAPL:

|--------+-------------------+--------+---------------------|
| \alpha | \alpha ○ \omega   | \alpha | \alpha ○ \omega     |
|--------+-------------------+--------+---------------------|
| 0      | (1-\omega⋆2)⋆0.5  |        |                     |
| ¯1     | Arcsin \omega     |      1 | Sin \omega          |
| ¯2     | Arccos \omega     |      2 | Cos \omega          |
| ¯3     | Arctan \omega     |      3 | Tan \omega          |
| ¯4     | (¯1+\omega⋆2)⋆0.5 |      4 | (1+\omega⋆2)≠0.5    |
| ¯5     | Arcsinh \omega    |      5 | Sinh \omega         |
| ¯6     | Arccosh \omega    |      6 | Cosh \omega         |
| ¯7     | Arctanh \omega    |      7 | Tanh \omega         |
| ¯8     | -8○\omega         |      8 | (¯1+\omega⋆2)⋆0.5   |
| ¯9     | \omega            |      9 | Real part of \omega |
| ¯10    | +\omega           |     10 | \vert \omega        |
| ¯11    | \omega × =0J1=      |     11 | Imag part of \omega |
| ¯12    | ⋆\omega           |     12 | Phase of \omega     |
|--------+-------------------+--------+---------------------|

Also notice that =0J1= is a complex number of real part =0= and imaginary
part =1=.

***** Domino operator

The Domino operator (=⌹=) generates the inverse of a matrix in its
monadic form, and divides a matrix by another in its dyadic form:

#+begin_src gnu-apl
MAT ← 2 2⍴⍳4
⌹MAT
5 6⌹MAT
#+end_src

**** Comparative functions

|----------+--------------+-----------------------|
| Function | Monadic form | Dyadic form           |
|----------+--------------+-----------------------|
| <        |              | Less than             |
| ≤        |              | Less than or equal    |
| =        |              | Equal                 |
| ≥        |              | Greater than or equal |
| >        |              | Greater than          |
| ≠        |              | Not equal             |
| ≡        | Depth        | Match                 |
| ≢        | Tally        | Not match             |
| ∊        | Enlist       | Membership            |
| ⍳        | Iota         | Index of              |
| ⍷        |              | Find                  |
|----------+--------------+-----------------------|

Here's an interesting use for comparative functions: Suppose we have a
table, where some numbers are negative. How can we test which numbers
are less than zero in it?

#+begin_src gnu-apl
TABLE ← 3 3⍴25-9?50
TABLE < 0
#+end_src

***** Equal underbar

The Equal underbar (=≡=) serves two purposes. In its monadic form, it
shows the depth of a specific structure.

#+begin_src gnu-apl
≡2 2⍴1 (2 3) (4 5 6 7) (8 (9 10) 11)
#+end_src

In its dyadic form, it attempts to match both parameters to see if
they are equal in shape, order and values:

#+begin_src gnu-apl
't' 'e' 's' 't'≡'test'
#+end_src

***** Equal underbar slash

The Equal underbar slash (=≢=) does the exact opposite of =≡=. In its
monadic form, it shows the tally (shallowest depth) of a specific
structure:

#+begin_src gnu-apl
≢2 2⍴1 (2 3) (4 5 6 7) (8 (9 10) 11)
#+end_src

In its dyadic form, it checks if both parameters *do not match*:

#+begin_src gnu-apl
('t' 'e') ('s' 't')≢'test'
#+end_src

***** Epsilon

The Epsilon (=∊=), in its dyadic form, checks whether the first
parameter is enclosed in the second parameter, thus testing for
membership:

#+begin_src gnu-apl
2∊1 2 3
#+end_src

The monadic form, however, /enlists/ a certain value. If it is a scalar,
it is put into a list; if it is a list, nothing changes; if it is a
matrix, rows will be put one after the other to form a single list.

#+begin_src gnu-apl
∊3 3 3⍴⍳27
#+end_src

***** Epsilon underbar

The Epsilon underbar (=⍷=) is only dyadic, and attempts to find the
first argument (which should be a pattern) inside the second
argument. The result should be a structure which marks where the
occurence starts for each occurence found.

#+begin_src gnu-apl
'ana' ⍷ 'banana'
#+end_src

***** Iota

The Iota (=⍳=) in its monadic form generates a list from =0= to =n=.

#+begin_src gnu-apl
⍳9
3 3⍴⍳9
#+end_src

In its dyadic form, it attempts to find the *second* argument inside the
*first* argument. The first match found returns the element index inside
the list, matrix, etc.

#+begin_src gnu-apl
X ← 0 0 5 3
X[(0≠0 0 5 3)⍳1] ⍝ Get first non-null element of X
#+end_src

**** Logical functions

These functions work only with yielding =0= or =1= by default, but they
are also used for /branching/.

All functions are dyadic, unless specified otherwise.

|----------+---------------|
| Function | Description   |
|----------+---------------|
| ~        | Not (Monadic) |
| ∨        | Or            |
| ∧        | And           |
| ⍱        | Nor           |
| ⍲        | Nand          |
|----------+---------------|

#+begin_src gnu-apl
~1 0 1
1 0 1∨0 0 1
1 0 1∧0 0 1
1 0 1⍱0 0 1
1 0 1⍲0 0 1
#+end_src

We can also short-circuit expressions. Should even be useful for
comparisions.

#+begin_src gnu-apl
(5 > 4) ∧ 1 < 3
#+end_src

**** Manipulative functions

|----------+--------------+---------------------|
| Function | Monadic form | Dyadic form         |
|----------+--------------+---------------------|
| ⍴        | Shape        | Reshape             |
| ,        | Ravel        | Catenate            |
| ~        | Not          | Without             |
| ⌽        | Reverse      | Rotate              |
| ⍉        | Transpose    | Dyadic transpose    |
| ↑        | Take first   | Take =n=              |
| ↓        |              | Drop =n=              |
| ⊂        | Enclose      | Partitioned enclose |
| ⊃        | Disclose     | Pick                |
| ∩        |              | Intersection        |
| ∪        | Unique       | Union               |
| ⊢        | Identity     | Right               |
| ⊣        | Identity     | Left                |
|----------+--------------+---------------------|

***** Comma

The Ravel (=,=) operator, in its monadic form, turns a matrix into a
list.

#+begin_src gnu-apl
X ← 3 3 3⍴⍳27 ⍝ A cube
,X
#+end_src

However, we can use axis parameters to induce other behaviours.

#+begin_src gnu-apl
,[1 2]X
#+end_src

The dyadic form catenates two structures. The particular behaviour is
determined by shape.

#+begin_src gnu-apl
(3 3⍴⍳9),(3 3⍴9+⍳9)
#+end_src

***** Circle Stile

The Reverse (=⌽=), in its monadic form, reverses the elements along the
last axis.

#+begin_src gnu-apl
⌽0 0 5 7
#+end_src

Its dyadic form performs a rotation on the elements of the second
parameter, in the last axis, by the number of elements specified in
the second parameter, as if the data were stored in a toroidal
shape. Number of rotated elements' sign provides the direction.

#+begin_src gnu-apl
2⌽3 3⍴⍳9
¯2⌽3 3⍴⍳9
#+end_src

***** Transpose

The Transpose (=⍉=), in its monadic form, reverses the axes of the given
matrix.

#+begin_src gnu-apl
⍉3 3⍴⍳9
#+end_src

In its dyadic form, we can directly instruct which axes are swapped
and how:

#+begin_src gnu-apl
2 1 3⍉3 3 3⍴⍳27    ⍝ Swap axes 1 and 2
#+end_src

***** Up Arrow

The Take function (=↑=), in its monadic form, gets the first element of
an array.

#+begin_src gnu-apl
↑3 1 2
#+end_src

In its dyadic form, it takes exactly the number of elements specified
at the first parameter, from the second parameter. If the absolute
number exceeds the length, the resulting list is zero-filled. If the
number is negative, it is taken from last element.

#+begin_src gnu-apl
2↑⌽⍳4
¯7↑⌽⍳4
#+end_src

***** Down Arrow

The Drop function (=↓=) has only a dyadic form, and drops the number of
elements in the first parameter from the second parameter list. If the
number is negative, the drop happens from the end. If the absolute
number exceeds the length, an empty response is returned.

***** Left Shoe

The Enclose (=⊂=) function, in its monadic form, encloses the given
object into a nested scalar.

#+begin_src gnu-apl
⊂2 2⍴⍳4
⍴⊂2 2⍴⍳4
#+end_src

In its dyadic form, it does a selective enclosing, returning the
enclosed objects:

#+begin_src gnu-apl
0 1 1 0⊂⍳4
#+end_src

***** Right Shoe

The Disclose (=⊃=) function, in its monadic form, discloses the single
elements of an object, zero-filling the missing elements so that all
of them belong to a single shape, with the same number of dimensions.

#+begin_src gnu-apl
⊃(⍳4) 2 3
#+end_src

In its dyadic form, it recursively picks up a certain element from a
nested structure.

#+begin_src gnu-apl
X ← 4⍴⊂(4 4⍴16?100)   ⍝ List of four enclosed 4x4 matrices
2 (2 2)⊃X             ⍝ Pick 2nd matrix, then pick element [2;2]
#+end_src

***** Right Tack

The Right (=⊢=) function does nothing in its monadic form, giving back
the untouched data. Its dyadic form, however, selects the left
element. It has a particularly useful property of selecting the
rightmost element when mapped over a structure:

#+begin_src gnu-apl
2 3⊢4 5
⊢/ 6 7 8 9
#+end_src

***** Left Tack

The Left (=⊣=) function works much like Right, except that it selects
the left element, or the leftmost element on a mapping:

#+begin_src gnu-apl
2 3⊣4 5
⊣/ 6 7 8 9
#+end_src

**** Sorting and coding functions

|----------+--------------+---------------------|
| Function | Monadic form | Dyadic form         |
|----------+--------------+---------------------|
| ⍋        | Grade up     | Collated grade up   |
| ⍒        | Grade down   | Collated grade down |
| ⊥        |              | Decode              |
| ⊤        |              | Encode              |
|----------+--------------+---------------------|

***** Grade Up

The Grade Up (=⍋=) function, in its monadic form, returns the indexes of
elements in ascending order.

#+begin_src gnu-apl
LIST ← 10?100
LIST[⍋LIST]
#+end_src

In its dyadic form, the first parameter is a collating sequence, which
enumerates top-priority elements for the ordering. Elements outside of
the collation are put in the end of the sequence.

#+begin_src gnu-apl
TEXT ← 'Banana'
TEXT['an'⍋TEXT]
#+end_src

***** Grade Down

The Grade Down (=⍒=) function works just like Grade Up, except that it
returns indexes of elements in descending order.

On the dyadic form, the collating sequence enumerates elements which
shall be ordered from rightmost to leftmost. Elements outside of the
collation are put in the beginning of the sequence.

#+begin_src gnu-apl
LIST ← 10?100
TEXT ← 'Banana'

LIST[⍒LIST]
TEXT['an'⍒TEXT]
#+end_src

***** Decode

The Decode (=⊥=) function converts a number (expressed as a list) on the
second argument to the base shown in the first argument.

#+begin_src gnu-apl
2⊥0 0 1 0 1
16⊥2 1
24 60 60⊥2 46 40  ⍝ Time conversion! 2h46m40s into total seconds
#+end_src

***** Encode

The Encode (=⊤=) function does the opposite of Decode.

#+begin_src gnu-apl
2 2 2 2⊤5 7 12
24 60 60⊤10000   ⍝ Mixed radix; convert 10000 seconds to h m s
#+end_src

**** Miscellaneous functions and other symbols

|----------+-------------------------------------------|
| Function | Meaning                                   |
|----------+-------------------------------------------|
| ⎕        | Numeric input from keyboard (niladic)     |
| ⍞        | Character input from keyboard (niladic)   |
| ◊        | Stament separator                         |
| ⍝        | Comment                                   |
| ⍎        | Evaluate text as APL expression (monadic) |
| ⍕        | Format (monadic/dyadic)                   |
| ⌷        | Index (dyadic)                            |
| ⍬        | Zilde                                     |
|----------+-------------------------------------------|

***** Diamond

The statement separator (=◊=) allows for inputting more than one
statement in a single line.

#+begin_src gnu-apl
LIST ← 25-(5?50) ◊ (÷LIST)
#+end_src

***** Hydrant

The Execute operator (=⍎=) evaluates a textual expression as an APL
statement.

#+begin_src gnu-apl
⍎'X ← 10×3 3⍴⍳9 ◊ ÷X'
#+end_src

***** Thorn

The Format operator (=⍕=) in its monadic form, transforms values into a
character list, suited to display onscreen.

#+begin_src gnu-apl
⍕1 2 3
#+end_src

Its dyadic form requires a format list as first argument, containing
the field width for each value and its number of decimal places. The
second argument is the values. If the field is not wide enough, it
gives a =DOMAIN ERROR=.

#+begin_src gnu-apl
6 2⍕3.25 3.002
⍝ 8 2⍕1234   ⍝ Not wide enough
#+end_src

***** Squad

The Index operator (=⌷=) has only a dyadic form, where one can pick
elements at something. It also supports axis parameters.

#+begin_src gnu-apl
TABLE ← 3 4⍴⍳12

2 3⌷TABLE
2⌷[1] TABLE
2⌷[2] TABLE
#+end_src

***** Zilde

The Empty Numeric Vector (=⍬=) is a vector of zero elements.

#+begin_src gnu-apl
⍝ These are a match, since they are numeric vectors.
⍬≡⍳0
⍬≡0⍴0

⍝ These do not match.
⍬≡0 0⍴0  ⍝ Not a vector
⍬≡''     ⍝ Not numeric
#+end_src

*** System functions

System functions exist to extend the power of APL, improving the
usable tasks.

See the implementation documentation for that.

** Built-in operators

#+begin_src gnu-apl
⍝ Built-in Operators
#+end_src

Operators are used to specify the way in which one or more functions
are applied to data. For example: repeatedly, cumulatively, etc.

|----------+-------------------|
| Operator | Name              |
|----------+-------------------|
| \slash   | Slash             |
| ⌿        | Slash bar         |
| \        | Backslash         |
| ⍀        | Backslash bar     |
| .        | Inner product     |
| ∘.       | Outer product     |
| ¨        | Each              |
| [ ]      | Axis              |
| ⍨        | Duplicate/Commute |
| ∘        | Compose           |
|----------+-------------------|

*** Reduce and scan

When used with functions as their operands, Slash and Backslash become
Reduce (=/=) and Scan (=\=), which apply a single function to all elements
of an argument.

#+begin_src gnu-apl
⍝ These two operations are equivalent
22 + 93 + 4.6 + 10 + 3.3
+/22 93 4.6 10 3.3        ⍝ Reduce using plus
#+end_src

In the last example, Reduce interposes the =+= between the values on the
vector. Were it replaced by the Scan operator, the same would happen,
but the result would be a vector containing intermediate results; the
last element of such vector would be the last result.

#+begin_src gnu-apl
+\22 93 4.6 10 3.3        ⍝ Scan using plus
22 (22+93) (115+4.6) (119.6+10) (129.6+3.3) ⍝ Equivalent calculation
#+end_src

**** Reduce First and Scan First

Using a Slash bar with a function means using the Reduce First (=⌿=)
operator. This will apply a reduction on the first dimension of the
data structure:

#+begin_src gnu-apl
TABLE ← 3 5⍴15?30
+⌿ TABLE
#+end_src

Using a Backslash bar with a function means using the Scan First (=⍀=)
operator. This does something similar to Scan, but stores each result
in a matrix row (first dimension).

#+begin_src gnu-apl
+⍀ TABLE
#+end_src

*** Compress and expand

When used with one or more *numbers*, Slash and Backslash become
Compression (=/=) and Expansion (=\=).

Compress selects a part of an object:

#+begin_src gnu-apl
1 0 1 1 0 1 / 'ABCDEF'
#+end_src

Expand inserts fill data into objects:

#+begin_src gnu-apl
TABLE ← 2 3⍴⍳6
⍝ Insert new columns (axis 2).
⍝ New columns indicated by zeroes.
1 0 1 0 1\[2]TABLE
#+end_src

**** Compress First and Expand First

The Compress First (=⌿=) operator, also known as Replicate First, is the
dyadic form of the Slash Bar, and can be used in a matrix to remove
and duplicate certain rows (first dimension):

#+begin_src gnu-apl
TABLE ← 3 4⍴⍳12
1 0 2⌿TABLE      ⍝ Remove 2nd row, duplicate 3rd row
#+end_src

The Expand First (=⍀=) operator is the dyadic version of the Backslash
bar, and also works by adding new rows (first dimension) to a matrix.

#+begin_src gnu-apl
TABLE ← 3 4⍴⍳12
1 0 1 0 1 0 0⍀TABLE
#+end_src

*** Outer and inner products

Product operators distribute the application of a function between
each element of one argument and all elements in another; this removes
the constraint on applying certain functions to arguments of same
shape.

**** Outer Product

The outer product (=∘.=)gives the result of applying the function to all
combinations of elements in both arguments:

#+begin_src gnu-apl
1 2 3∘.+4 5 6
#+end_src

The result is a 3×3 matrix, where the first column is the sum between
=1= and each of the numbers in the second argument; the second column is
the sum between =2= and each of the numbers in the second argument; and
so on.

Another example: a matrix of powers.

#+begin_src gnu-apl
(⍳4)∘.*⍳4
#+end_src

**** Inner Product

The inner product (=.=) allows two functions to be applied to arguments;
operations happen between the *last* dimension of the *left* argument, and
the *first* dimension of the *right* argument; so the two inner dimensions
are used.

Using this on matrices results in two steps:
1. Each *row* of the *left* argument is applied to each *column* of the
   *right* argument. This uses the rightmost function;
2. The leftmost function is applied to the result, through a Reduction
   (=/=).

#+begin_src gnu-apl
X←3 3⍴9?100
Y←3 3⍴9?100

⍝ 1. Each row of X is multiplied by each column of Y;
⍝ 2. The result is reduced through a sum.
X+.×Y
#+end_src

There are up to 400 possible inner products. Some uses are:
- Locating incidences of given character strings within textual data;
- Evaluation of polynomials;
- Matrix multiplication;
- Product of powers;
- Etc.

*** Each

The Each operator (=¨=) allows applying a certain function (on the left)
to each elements of an array or vector (on the right).

#+begin_src gnu-apl
⍴¨(⍳3)(⍳2)(⍳5)   ⍝ Find the length of each vector
#+end_src

*** Axis

Some functions operate in data which has more than one dimension. One
can change the axis in which they operate by using the axis operator.

By default, APL functions work on the *last* dimension of your data. The
order of dimensions is the one show when you apply =⍴= to the data.

#+begin_src gnu-apl
TABLE ← 2 3⍴⍳6  ⍝ A matrix of 2×3 (two dimensions)

⍝ Reduce with + on the second dimension. This gives a
⍝ list of two numbers, each being the sum of numbers
⍝ along the COLUMNS (dimension 2, last one) of each
⍝ row of the matrix.
+/TABLE

⍝ This reduction specifies that the sum should occur
⍝ along the ROWS (dimension 1) of a column of the
⍝ matrix, therefore it gives a list of three numbers.
+/[1]TABLE
#+end_src

**** Functions that accept axis specifications

here are some built-in functions and operators that accept specifying
axes:

- Functions
  - =↑= (First, Take)
  - =↓= (Drop)
  - =⊂= (Enclose, Partition)
  - =⊃= (Disclose, Pick)
  - =,= (Ravel, Catenate)
  - =⌽=, =⊖= (Reversal, Rotation)

- Operators
  - =/= (Reduce, Compress)
  - =\= (Scan, Expand)
  - =⌿= (Reduce First, Compress First)
  - =⍀= (Scan First, Compress First)

** User-defined Functions

#+begin_src gnu-apl
⍝ User-defined functions
#+end_src

*** Arguments and results

Functions can be thought of as external programs which are run. They
can be:

- *Niladic*: They have no specified arguments.
- *Monadic*: Functions have one argument, passed at its right.
- *Dyadic*:  Functions have two arguments, the first is passed at its
  left and the second is passed at its right.

Passing many values as an argument is enclosed into a single vector of
arguments.

Definining a function that is both *monadic* and *dyadic* require testing
the first and second arguments to dispatch based on it.

If you need to express a result, you will also need to give a name for
the result field.

*** User-defined operators

Operators must have one or two *operands*, which are functions; not more
nor less, since operators are used to modify the behaviour of
functions.

*** Editing functions

Some APLs allow you to edit a function by using the =)EDIT= command or
the =⎕EDIT= system function. This is the case for Dyalog, for example --
however, Dyalog uses the =)ED= command instead.

#+begin_src gnu-apl :tangle no
)ED FUNK
#+end_src

Older APL systems, like GNU APL, allows editing one-line-at-time,
using the Del (=∇=) editor. However, the =gnu-apl-mode= for Emacs replaces
the use of Del by opening a new temporary buffer to edit the function.

#+begin_src gnu-apl :tangle no
∇FUNK
#+end_src

APL uses the concept of workspaces to store functions and values,
however one can safely use the Del (=∇=) notation to define a certain
function in an APL code file:

#+begin_src gnu-apl :tangle no
∇FUNK
  ⍝ Add some code here...
∇
#+end_src

The rest of this text will use the Del editor notation, in a way which
it can be executed in a GNU APL script, therefore some things will be
different e.g. line numbers will not be used here.

*** The function header

When typing the function, one must type a suitable function header,
for example:

#+begin_src gnu-apl
∇SD X
  SUM ← +/X
  AVG ← SUM÷⍴X
  DIFF ← AVG-X
  SQDIFF ← DIFF⋆2
  SQAVG ← (+/SQDIFF)÷⍴SQDIFF
  RESULT ← SQAVG⋆0.5
∇
#+end_src

This function takes a vector called =X= and performs some computation
using it.

#+begin_src gnu-apl
SD 12 45 20 68 92 108
#+end_src

The result exists in the global variable =RESULT=, created inside the
function.

If we were defining a function with two operators, we would have a
header such as:

#+begin_src gnu-apl :tangle no
∇X CALC Y
#+end_src

And if we wanted the result to be put in a specific variable, see how
we could redefine =SD=:

#+begin_src gnu-apl
∇R ← SD X
  SUM ← +/X
  AVG ← SUM÷⍴X
  DIFF ← AVG-X
  SQDIFF ← DIFF⋆2
  SQAVG ← (+/SQDIFF)÷⍴SQDIFF
  R ← SQAVG⋆0.5
∇
#+end_src

By doing this, the result of applying =SD= to something could be
assigned to a variable; =R= itself is not a variable which is visible
outside of =SD=, acting as a surrogate for the final result of
execution.

*** The operator header

Operator bodies are defined just like functions'; what changes is the
header, which must specify an operator.

Here is the header of a monadic operator:

#+begin_src gnu-apl :tangle no
∇R ← X (LOP OPERATE) Y
#+end_src

And the header of a dyadic operator:

#+begin_src gnu-apl :tangle no
∇R ← X (LOP OPERATE ROP) Y
#+end_src

- =OPERATE= is the operator name;
- =R= is the optional return variable;
- =X= and =Y= are left and right parameters for the operator;
- =LOP= is an obligatory left operand, which the operator will change
  the behaviour of;
- =ROP= is an optional right operand, which the operator will also
  change the behaviour of.

*** Local and global variables

One can quote variables in the header to make sure they are *local* to
the function; by not doing so, they will remain *global*. Also notice
that local variables are not shared with variables called inside the
function body.

So let's fix =SD=.

#+begin_src gnu-apl
)CLEAR   ⍝ Clear the workspace

∇R ← SD X;SUM;AVG;DIFF;SQDIFF;SQAVG
  SUM ← +/X
  AVG ← SUM÷⍴X
  DIFF ← AVG-X
  SQDIFF ← DIFF⋆2
  SQAVG ← (+/SQDIFF)÷⍴SQDIFF
  R ← SQAVG⋆0.5
∇
#+end_src

But the header is so big, that's not good. Let's try making this a
little more compact so we have fewer local variables.

#+begin_src gnu-apl
∇R ← SD X;SQDIFF
  SQDIFF ← (X-(+/X)÷⍴X)⋆2
  R ← ((+/SQDIFF)÷⍴SQDIFF)⋆0.5
∇
#+end_src

*** Branching

To-do.
