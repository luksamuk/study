#+title: Bancos de Dados I
#+subtitle: Estudos de Queries
#+author: Lucas S. Vieira
#+startup: content
#+PROPERTY: header-args:sql :engine mysql :dbport 3306 :dbuser root :dbpassword root_pw :dbhost 172.17.0.2 :exports both

* Índice :TOC_3:
- [[#introdução][Introdução]]
- [[#subindo-o-mariadb-localmente][Subindo o MariaDB localmente]]
  - [[#criando-o-contêiner][Criando o contêiner]]
  - [[#verificando-se-o-contêiner-está-rodando][Verificando se o contêiner está rodando]]
  - [[#conexão-via-console][Conexão via console]]
    - [[#usando-docker][Usando Docker]]
    - [[#usando-uma-ferramenta-externa][Usando uma ferramenta externa]]
- [[#suporte-ao-emacs][Suporte ao Emacs]]
- [[#aula-10a-criando-um-banco-de-dados][Aula 10A: Criando um banco de dados]]
  - [[#criando-tabelas][Criando tabelas]]
    - [[#departamentos][Departamentos]]
    - [[#empregados][Empregados]]
    - [[#projetos][Projetos]]
    - [[#relação-empregadoprojeto][Relação Empregado/Projeto]]
- [[#aula-10b-modificando-tabelas][Aula 10B: Modificando tabelas]]
  - [[#adicionando-uma-coluna-na-tabela-empregado][Adicionando uma coluna na tabela ~empregado~]]
  - [[#alterar-estrutura-da-coluna-nome-em-empregado][Alterar estrutura da coluna ~nome~ em ~empregado~]]
  - [[#remover-coluna-datanasc-em-empregado][Remover coluna ~datanasc~ em ~empregado~]]
  - [[#modificar-novamente-nome-em-empregado][Modificar novamente ~nome~ em ~empregado~]]
  - [[#mostrando-as-tabelas-criadas][Mostrando as tabelas criadas]]
  - [[#inserindo-dados-nas-tabelas][Inserindo dados nas tabelas]]
    - [[#adicionando-departamentos][Adicionando departamentos]]
    - [[#adicionando-projetos][Adicionando projetos]]
    - [[#adicionando-empregados][Adicionando empregados]]
    - [[#adicionando-relações-empregadoprojeto][Adicionando relações Empregado/Projeto]]
- [[#aula-10c-parte-1-consultas-com-o-comando-select][Aula 10C, parte 1: Consultas com o comando ~SELECT~]]
  - [[#mostrando-todos-os-dados][Mostrando todos os dados]]
  - [[#mostrando-apenas-algumas-colunas][Mostrando apenas algumas colunas]]
  - [[#filtrando-linhas-da-tabela][Filtrando linhas da tabela]]
  - [[#cláusula-join][Cláusula ~JOIN~]]
    - [[#combinando-empregados-e-departamentos][Combinando empregados e departamentos]]
    - [[#combinando-empregados-projetos-e-horas-gastas-no-projeto][Combinando empregados, projetos, e horas gastas no projeto]]
  - [[#cláusula-order-by][Cláusula ~ORDER BY~]]
    - [[#ordenação-descendente][Ordenação descendente]]
    - [[#ordenação-com-mais-de-um-critério][Ordenação com mais de um critério]]
    - [[#ordenação-com-critérios-de-diferentes-tipos][Ordenação com critérios de diferentes tipos]]
- [[#aula-10c-parte-2-funções-de-agregação][Aula 10C, parte 2: Funções de agregação]]
  - [[#função-count][Função ~COUNT~]]
    - [[#contagem-de-elementos-distintos][Contagem de elementos distintos]]
    - [[#cláusula-de-critério-de-agrupamento-group-by][Cláusula de critério de agrupamento: ~GROUP BY~]]
  - [[#usando-count-e-join-em-conjunto][Usando ~COUNT~ e ~JOIN~ em conjunto]]
    - [[#usando-cláusula-where][Usando cláusula ~WHERE~]]
    - [[#ordenando-resultado-pela-agregação][Ordenando resultado pela agregação]]
  - [[#função-max][Função ~MAX~]]
  - [[#função-min][Função ~MIN~]]
  - [[#função-avg][Função ~AVG~]]
  - [[#consulta-com-predicado-envolvendo-função-de-agregação][Consulta com predicado envolvendo função de agregação]]
  - [[#operador-like][Operador ~LIKE~]]
- [[#aula-10d-atualização-e-remoção-de-informações][Aula 10D: Atualização e remoção de informações]]
  - [[#comando-update][Comando ~UPDATE~]]
    - [[#alterando-empregados][Alterando empregados]]
    - [[#observação][Observação]]
    - [[#alterando-departamentos][Alterando departamentos]]
    - [[#alterando-relações-entre-empregados-e-projetos][Alterando relações entre empregados e projetos]]
  - [[#comando-delete][Comando ~DELETE~]]
    - [[#deletando-empregados][Deletando empregados]]
    - [[#observação-1][Observação]]
    - [[#deletando-departamentos-ou-pelo-menos-tentando][Deletando departamentos (ou pelo menos tentando)]]
    - [[#deletando-relações-empregado-x-projeto][Deletando relações empregado x projeto]]
- [[#formas-normais][Formas normais]]
  - [[#1fn][1FN]]
  - [[#2fn][2FN]]
  - [[#3fn][3FN]]

* Introdução

As seções a  seguir descrevem exemplos e estudo  de queries realizados
para  a disciplina  de Bancos  de  Dados I,  do curso  de Sistemas  de
Informação, da UFVJM.

As queries foram executadas em  uma instalação local do MariaDB, feita
em um contêiner, através da ferramenta Docker.

Este documento foi criado através do editor de texto Emacs, utilizando
o  formato de  texto Org.  Isso significa  que foram  inseridos blocos
individuais de código e, através de configuração especial, tais blocos
foram executados,  de forma  que gerassem  as saídas  subsequentes aos
mesmos.

* Subindo o MariaDB localmente

MariaDB é  um fork  opensource de MySQL.  Optei por  usá-lo localmente
através do Docker.

Por sorte, já existe uma imagem do MariaDB no DockerHub que facilita a
minha vida.

Para   começar,  o   Docker  está   adequadamente  instalado   no  meu
Linux. Então, basta que eu puxe  a imagem Docker, crie um contêiner, e
execute tudo localmente.

Para maiores  informações, a [[https://mariadb.com/kb/en/installing-and-using-mariadb-via-docker/][documentação  do MariaDB]] é  fantástica de
consultar.

** Criando o contêiner

Isso aqui instala a imagem:

#+begin_src bash
docker pull mariadb/server:10.4
#+end_src

E isso cria um contêiner:

#+begin_src bash
docker run --name dbms-bd1 \
       -p 3306:3306 \
       -e MYSQL_ROOT_PASSWORD="root_pw" \
       -d mariadb/server:10.4
#+end_src

Este último  comando cria um  contêiner de nome ~dbms-bd1~,  que exporta
sua porta ~3306~ para a porta ~3306~  da máquina, e define a senha de root
como ~root_pw~,  que é  o que  usaremos para  acessar, juntamente  com o
usuário ~root~.

Gerenciar o contêiner  é algo simples. Ao executar o  comando acima, o
contêiner já estará em execução. Para interromper sua operação, faça:

#+begin_src bash :eval no
docker stop dbms-bd1
#+end_src

E, caso queira iniciar novamente o contêiner:

#+begin_src bash :eval no
docker start dbms-bd1
#+end_src

** Verificando se o contêiner está rodando

Esse comando verifica se o  contêiner está em execução. Podemos também
verificar se a porta está adequadamente redirecionada através dele.

#+begin_src bash :cache yes :results verbatim :exports both
docker ps
#+end_src

#+RESULTS[19a07da4f43b29619840b427e896765054a702cc]:
: CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                    NAMES
: 16f6d547ea84        mariadb/server:10.4   "docker-entrypoint.s…"   3 hours ago         Up 3 hours          0.0.0.0:3306->3306/tcp   dbms-bd1

*NOTA:* A linha abaixo é um utilitário para remover todos os contêineres
que estejam instalados localmente. Pode ser útil no futuro.

#+begin_src bash :eval no
docker ps -a | awk '{if (NR!=1) print $1}' | xargs docker rm
#+end_src

** Conexão via console

*** Usando Docker

Para  iniciar  uma linha  de  comando  interativa  que se  conecte  ao
MariaDB, podemos usar o comando a seguir em um terminal:

#+begin_src bash :eval no
docker exec -it dbms-bd1 mysql -uroot -proot_pw
#+end_src

*** Usando uma ferramenta externa

Para  nos  conectarmos  usando   uma  ferramenta  externa,  precisamos
encontrar o IP do contêiner.  Isso pode ser feito com esse comando:

#+begin_src bash :exports both
docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' dbms-bd1
#+end_src

#+RESULTS:
: 172.17.0.2

Em seguida, podemos usar os binários locais normalmente.

#+begin_src bash :eval no
mysql -h 172.17.0.2 -P 3306 -uroot -proot_pw
#+end_src

* Suporte ao Emacs

No Emacs, uso dois pacotes interessantes:

1.  ~ob-sql-mode~: Para  interpretar  blocos de  código SQL  diretamente
   neste arquivo de texto;
2. ~edbi~: Solução gráfica para explorar um banco de dados.

Para usar ~edbi~, use ~M-x edbi:open-db-viewer~.

~edbi~ requer uma string de data source. É possível usar algo como:

#+begin_example
dbi:mysql:host=172.17.0.2;port=3306;dbname=empresa;charset=utf8mb4
#+end_example

Caso você  tenha algum problema  com o ~edbi~ reclamando  de bibliotecas
Perl faltantes,  execute isso no  console, assumindo que você  tenha o
~cpan~ instalado. Essa operação vai instalar drivers faltantes.

Para mais informações, veja o repositório do [[https://github.com/kiwanami/emacs-edbi][Emacs DBI]].

#+begin_src bash :eval no
cpan RPC::EPC::Service DBI DBD::SQLite DBD::Pg DBD::mysql
#+end_src

Vamos testar  com um  bloco de  código. Para  tanto, é  necessário ter
instalado o ~mysql~  ou o ~mariadb~, pois vamos usar  o comando ~mysql~ pelo
console para nos conectarmos.

#+begin_src sql
show databases;
#+end_src

#+RESULTS:
| Database           |
|--------------------|
| information_schema |
| mysql              |
| performance_schema |

* Aula 10A: Criando um banco de dados

A operação a seguir precisa ser feita através de console interativo.

Vamos criar um banco de dados para as lições:

#+begin_src sql :eval no
create database empresa;
#+end_src

#+RESULTS:
||

Caso você queira continuar no  console interativo, use o seguinte para
ir para o banco de dados em questão:

#+begin_src sql :eval no
use empresa;
#+end_src

** Criando tabelas

Vamos agora criar algumas tabelas no nosso banco de dados.

*** Departamentos

Primeiramente, vamos  criar uma  tabela para  os departamentos  de uma
empresa, onde teremos:

- ~numero~: Número inteiro, chave primária do departamento;
- ~nome~: Varchar de 50 caracteres.

#+header: :database empresa
#+begin_src sql
create table departamento(
       numero integer primary key,
       nome varchar(50));
#+end_src

#+RESULTS:
||

#+header: :database empresa
#+begin_src sql
describe departamento;
#+end_src

#+RESULTS:
| Field  | Type        | Null | Key | Default | Extra |
|--------+-------------+------+-----+---------+-------|
| numero | int(11)     | NO   | PRI | NULL    |       |
| nome   | varchar(50) | YES  |     | NULL    |       |

*** Empregados

Vamos criar uma tabela para os empregados. Nela, temos:

- ~cpf~: Número BigInt, chave primária do empregado;
- ~nome~: Varchar de 50 caracteres, não-nulo;
- ~endereco~: Varchar de 50 caracteres, não-nulo;
- ~depto_fk~: Número inteiro, referencia a chave de um departamento.

Usaremos  BigInt para  o CPF,  posto  que o  CPF possui  mais de  oito
dígitos.

#+header: :database empresa
#+begin_src sql
create table empregado(
       cpf bigint primary key,
       nome varchar(50) not null,
       endereco varchar(50) not null,
       depto_fk integer,
       foreign key(depto_fk) references departamento(numero));
#+end_src

#+RESULTS:
||

#+header: :database empresa
#+begin_src sql
describe empregado;
#+end_src

#+RESULTS:
| Field    | Type        | Null | Key | Default | Extra |
|----------+-------------+------+-----+---------+-------|
| cpf      | bigint(20)  | NO   | PRI | NULL    |       |
| nome     | varchar(50) | NO   |     | NULL    |       |
| endereco | varchar(50) | NO   |     | NULL    |       |
| depto_fk | int(11)     | YES  | MUL | NULL    |       |

*** Projetos

Vamos criar uma tabela para os projetos:

- ~numero~: Número inteiro, chave primária do projeto;
- ~nome~: Varchar de 30 caracteres, não-nulo.

#+header: :database empresa
#+begin_src sql
create table projeto(
       numero integer primary key,
       nome varchar(30) not null);
#+end_src

#+RESULTS:
||

#+header: :database empresa
#+begin_src sql
describe projeto;
#+end_src

#+RESULTS:
| Field  | Type        | Null | Key | Default | Extra |
|--------+-------------+------+-----+---------+-------|
| numero | int(11)     | NO   | PRI | NULL    |       |
| nome   | varchar(30) | NO   |     | NULL    |       |

*** Relação Empregado/Projeto

Para relacionarmos empregados a determinados projetos, teremos:

- ~cpf~: Número  BigInt, não-nulo, parte  da chave primária  composta da
  relação, referência ao ~cpf~ de um empregado;
- ~numero~: Número  inteiro, não-nulo, parte da  chave primária composta
  da relação, referência ao ~numero~ de um projeto;
- ~horas~: Número float.

#+header: :database empresa
#+begin_src sql
create table emp_proj(
       cpf bigint not null,
       numero integer not null,
       horas float,
       primary key(cpf, numero),
       foreign key(cpf) references empregado(cpf),
       foreign key(numero) references projeto(numero));
#+end_src

#+RESULTS:
||

#+header: :database empresa
#+begin_src sql
describe emp_proj;
#+end_src

#+RESULTS:
| Field  | Type       | Null | Key | Default | Extra |
|--------+------------+------+-----+---------+-------|
| cpf    | bigint(20) | NO   | PRI | NULL    |       |
| numero | int(11)    | NO   | PRI | NULL    |       |
| horas  | float      | YES  |     | NULL    |       |

* Aula 10B: Modificando tabelas

** Adicionando uma coluna na tabela ~empregado~

#+header: :database empresa
#+begin_src sql
alter table empregado
add column datanasc datetime;
#+end_src

#+RESULTS:
|   |

#+header: :database empresa
#+begin_src sql :cache yes
describe empregado;
#+end_src

#+RESULTS[aca4ab9dc1ea1ed3ef7f2cc09ab40e65678fd33c]:
| Field    | Type        | Null | Key | Default | Extra |
|----------+-------------+------+-----+---------+-------|
| cpf      | bigint(20)  | NO   | PRI | NULL    |       |
| nome     | varchar(50) | NO   |     | NULL    |       |
| endereco | varchar(50) | NO   |     | NULL    |       |
| depto_fk | int(11)     | YES  | MUL | NULL    |       |
| datanasc | datetime    | YES  |     | NULL    |       |

** Alterar estrutura da coluna ~nome~ em ~empregado~

#+header: :database empresa
#+begin_src sql
alter table empregado
modify column nome varchar(90) not null;
#+end_src

#+RESULTS:
|   |

#+header: :database empresa
#+begin_src sql :cache yes
describe empregado;
#+end_src

#+RESULTS[aca4ab9dc1ea1ed3ef7f2cc09ab40e65678fd33c]:
| Field    | Type        | Null | Key | Default | Extra |
|----------+-------------+------+-----+---------+-------|
| cpf      | bigint(20)  | NO   | PRI | NULL    |       |
| nome     | varchar(90) | NO   |     | NULL    |       |
| endereco | varchar(50) | NO   |     | NULL    |       |
| depto_fk | int(11)     | YES  | MUL | NULL    |       |
| datanasc | datetime    | YES  |     | NULL    |       |

** Remover coluna ~datanasc~ em ~empregado~

#+header: :database empresa
#+begin_src sql
alter table empregado
drop column datanasc;
#+end_src

#+RESULTS:
|   |

#+header: :database empresa
#+begin_src sql :cache yes
describe empregado;
#+end_src

#+RESULTS[aca4ab9dc1ea1ed3ef7f2cc09ab40e65678fd33c]:
| Field    | Type        | Null | Key | Default | Extra |
|----------+-------------+------+-----+---------+-------|
| cpf      | bigint(20)  | NO   | PRI | NULL    |       |
| nome     | varchar(90) | NO   |     | NULL    |       |
| endereco | varchar(50) | NO   |     | NULL    |       |
| depto_fk | int(11)     | YES  | MUL | NULL    |       |

** Modificar novamente ~nome~ em ~empregado~

#+header: :database empresa
#+begin_src sql
alter table empregado
modify column nome varchar(50) not null;
#+end_src

#+RESULTS:
|   |

#+header: :database empresa
#+begin_src sql :cache yes
describe empregado;
#+end_src

#+RESULTS[aca4ab9dc1ea1ed3ef7f2cc09ab40e65678fd33c]:
| Field    | Type        | Null | Key | Default | Extra |
|----------+-------------+------+-----+---------+-------|
| cpf      | bigint(20)  | NO   | PRI | NULL    |       |
| nome     | varchar(50) | NO   |     | NULL    |       |
| endereco | varchar(50) | NO   |     | NULL    |       |
| depto_fk | int(11)     | YES  | MUL | NULL    |       |

** Mostrando as tabelas criadas

#+header: :database empresa
#+begin_src sql
show tables;
#+end_src

#+RESULTS:
| Tables_in_empresa |
|-------------------|
| departamento      |
| emp_proj          |
| empregado         |
| projeto           |

** Inserindo dados nas tabelas

Para criar relações  entre empregados e projetos,  precisamos de dados
nessas respectivas tabelas, antes de mais nada.

Os  exemplos a  seguir também  usam  queries com  ~select~, apenas  para
visualizar os dados da tabela.

*** Adicionando departamentos

#+header: :database empresa
#+begin_src sql
insert into departamento(numero, nome)
values(1, 'Administração'),
      (2, 'Recursos humanos'),
      (3, 'Operação');
#+end_src

#+RESULTS:
|   |

#+header: :database empresa
#+begin_src sql :cache yes
select * from departamento;
#+end_src

#+RESULTS[83f1c43502192f03adf2e365ca8bd8d4aebe905b]:
| numero | nome             |
|--------+------------------|
|      1 | Administração    |
|      2 | Recursos humanos |
|      3 | Operação         |

*** Adicionando projetos

#+header: :database empresa
#+begin_src sql
insert into projeto(numero, nome)
values(1, 'Projeto A'),
      (2, 'Projeto B'),
      (3, 'Projeto C');
#+end_src

#+RESULTS:
|   |

#+header: :database empresa
#+begin_src sql :cache yes
select * from projeto;
#+end_src

#+RESULTS[0f3ee9e0fa8d99d9feaae7c9fff484394d330582]:
| numero | nome      |
|--------+-----------|
|      1 | Projeto A |
|      2 | Projeto B |
|      3 | Projeto C |

*** Adicionando empregados

#+header: :database empresa
#+begin_src sql
insert into empregado(cpf, nome, endereco, depto_fk)
values(11122233344, 'José da Silva', 'Rua C, 44, Centro, Diamantina', 1),
      (22233344455, 'Maria Rosa', 'Rua B, 22, Centro, Diamantina', 2),
      (33344455566, 'João Jesus', 'Rua D, 15, Palha, Diamantina', 2),
      (44455566677, 'Josuel Santos', 'Rua Domingos, 22, Centro, Diamantina', 3);
#+end_src

#+RESULTS:
|   |

#+header: :database empresa
#+begin_src sql :cache yes
select * from empregado;
#+end_src

#+RESULTS[c23913a329c2ca162bdc93ca7c46c65ddd33c413]:
|         cpf | nome          | endereco                             | depto_fk |
|-------------+---------------+--------------------------------------+----------|
| 11122233344 | José da Silva | Rua C, 44, Centro, Diamantina        |        1 |
| 22233344455 | Maria Rosa    | Rua B, 22, Centro, Diamantina        |        2 |
| 33344455566 | João Jesus    | Rua D, 15, Palha, Diamantina         |        2 |
| 44455566677 | Josuel Santos | Rua Domingos, 22, Centro, Diamantina |        3 |

*** Adicionando relações Empregado/Projeto

#+header: :database empresa
#+begin_src sql
insert into emp_proj(cpf, numero, horas)
values(11122233344, 1, 33),
      (22233344455, 2, 15),
      (33344455566,2, 20),
      (44455566677,3, 17);
#+end_src

#+RESULTS:
|   |

#+header: :database empresa
#+begin_src sql :cache yes
select * from emp_proj;
#+end_src

#+RESULTS[e7929de4e518c3635c23ec9c39a04dd07adb0ba9]:
|         cpf | numero | horas |
|-------------+--------+-------|
| 11122233344 |      1 |    33 |
| 22233344455 |      2 |    15 |
| 33344455566 |      2 |    20 |
| 44455566677 |      3 |    17 |

* Aula 10C, parte 1: Consultas com o comando ~SELECT~

** Mostrando todos os dados

Começaremos  com um  exemplo  que  recupera todas  as  colunas de  uma
determinada tabela.

#+begin_src sql :database empresa
select * from empregado;
#+end_src

#+RESULTS:
|         cpf | nome          | endereco                             | depto_fk |
|-------------+---------------+--------------------------------------+----------|
| 11122233344 | José da Silva | Rua C, 44, Centro, Diamantina        |        1 |
| 22233344455 | Maria Rosa    | Rua B, 22, Centro, Diamantina        |        2 |
| 33344455566 | João Jesus    | Rua D, 15, Palha, Diamantina         |        2 |
| 44455566677 | Josuel Santos | Rua Domingos, 22, Centro, Diamantina |        3 |

** Mostrando apenas algumas colunas

A seguir, vamos recuperar apenas as colunas ~cpf~ e ~nome~ dos empregados.

#+begin_src sql :database empresa
select cpf, nome from empregado;
#+end_src

#+RESULTS:
|         cpf | nome          |
|-------------+---------------|
| 11122233344 | José da Silva |
| 22233344455 | Maria Rosa    |
| 33344455566 | João Jesus    |
| 44455566677 | Josuel Santos |

** Filtrando linhas da tabela

Vamos filtrar as linhas de acordo com um certo predicado.

#+begin_src sql :database empresa
select * from empregado where depto_fk=1;
#+end_src

#+RESULTS:
|         cpf | nome          | endereco                      | depto_fk |
|-------------+---------------+-------------------------------+----------|
| 11122233344 | José da Silva | Rua C, 44, Centro, Diamantina |        1 |

Podemos também usar  ~and~ e ~or~ para realizar mais  operações lógicas na
query.

As  operações  lógicas também  podem  admitir  parênteses para  melhor
controle de sua operação.

#+begin_src sql :database empresa
select * from empregado
where depto_fk=1 or cpf=33344455566;
#+end_src

#+RESULTS:
|         cpf | nome          | endereco                      | depto_fk |
|-------------+---------------+-------------------------------+----------|
| 11122233344 | José da Silva | Rua C, 44, Centro, Diamantina |        1 |
| 33344455566 | João Jesus    | Rua D, 15, Palha, Diamantina  |        2 |

** Cláusula ~JOIN~

Podemos realizar consultas que reúnem registros de tabelas diferentes,
ou que combinam registros de uma mesma tabela.

*** Combinando empregados e departamentos

Aqui, combinamos o CPF e o nome de  um empregado com o número e o nome
de seu departamento.

#+begin_src sql :database empresa
select cpf, e.nome, depto_fk, d.nome
from empregado as e
join departamento as d
on e.depto_fk = d.numero;
#+end_src

#+RESULTS:
|         cpf | nome          | depto_fk | nome             |
|-------------+---------------+----------+------------------|
| 11122233344 | José da Silva |        1 | Administração    |
| 22233344455 | Maria Rosa    |        2 | Recursos humanos |
| 33344455566 | João Jesus    |        2 | Recursos humanos |
| 44455566677 | Josuel Santos |        3 | Operação         |

*** Combinando empregados, projetos, e horas gastas no projeto

Essa  query com  ~JOIN~ envolve  a  união de  três tabelas:  empregados,
projetos, e a relação empregado/projeto.

#+begin_src sql :database empresa
select e.cpf, e.nome, p.nome, horas
from empregado as e
join emp_proj as pj on e.cpf = pj.cpf
join projeto as p on pj.numero = p.numero;
#+end_src

#+RESULTS:
|         cpf | nome          | nome      | horas |
|-------------+---------------+-----------+-------|
| 11122233344 | José da Silva | Projeto A |    33 |
| 22233344455 | Maria Rosa    | Projeto B |    15 |
| 33344455566 | João Jesus    | Projeto B |    20 |
| 44455566677 | Josuel Santos | Projeto C |    17 |

** Cláusula ~ORDER BY~

Esta  cláusula  ordena  o  resultado  da consulta  de  acordo  com  um
critério, relacionado ao valor de uma ou mais colunas.

#+begin_src sql :database empresa
select e.cpf, e.nome, p.nome, horas
from empregado as e
join emp_proj as pj on e.cpf = pj.cpf
join projeto as p on pj.numero = p.numero
order by e.nome;
#+end_src

#+RESULTS:
|         cpf | nome          | nome      | horas |
|-------------+---------------+-----------+-------|
| 33344455566 | João Jesus    | Projeto B |    20 |
| 11122233344 | José da Silva | Projeto A |    33 |
| 44455566677 | Josuel Santos | Projeto C |    17 |
| 22233344455 | Maria Rosa    | Projeto B |    15 |

*** Ordenação descendente

A ordenação pode ser invertida  através da utilização da palavra-chave
~DESC~, que instrui uma ordenação descendente.

#+begin_src sql :database empresa
select e.cpf, e.nome, p.nome, horas
from empregado as e
join emp_proj as pj on e.cpf = pj.cpf
join projeto as p on pj.numero = p.numero
order by e.nome desc;
#+end_src

#+RESULTS:
|         cpf | nome          | nome      | horas |
|-------------+---------------+-----------+-------|
| 22233344455 | Maria Rosa    | Projeto B |    15 |
| 44455566677 | Josuel Santos | Projeto C |    17 |
| 11122233344 | José da Silva | Projeto A |    33 |
| 33344455566 | João Jesus    | Projeto B |    20 |

*** Ordenação com mais de um critério

/(Este exemplo é ligeiramente modificado com relação ao da aula para se
enquadrar nos dados previamente inseridos.)/

Podemos também realizar  ordenação de acordo com nomes  dos projetos e
nomes dos empregados, de forma descendente.

Dessa  forma, quando  dois  empregados "empatarem"  em  seus nomes  de
projetos, os mesmos  serão ordenados de acordo com  a ordem alfabética
de seus próprios nomes.

#+begin_src sql :database empresa
select p.nome, horas, e.cpf, e.nome
from empregado as e
join emp_proj as pj on e.cpf = pj.cpf
join projeto as p on pj.numero = p.numero
order by p.nome, e.nome desc;
#+end_src

#+RESULTS:
| nome      | horas |         cpf | nome          |
|-----------+-------+-------------+---------------|
| Projeto A |    33 | 11122233344 | José da Silva |
| Projeto B |    15 | 22233344455 | Maria Rosa    |
| Projeto B |    20 | 33344455566 | João Jesus    |
| Projeto C |    17 | 44455566677 | Josuel Santos |

*** Ordenação com critérios de diferentes tipos

A consulta a  seguir usa o valor  das horas do projeto  da mesma forma
como o exemplo anterior. Assim, o  valor das horas constitui o segundo
critério de ordenação, após o nome do empregado.

#+begin_src sql :database empresa
select e.cpf, e.nome, p.nome, horas
from empregado as e
join emp_proj as pj on e.cpf = pj.cpf
join projeto as p on pj.numero = p.numero
order by e.nome, horas;
#+end_src

#+RESULTS:
|         cpf | nome          | nome      | horas |
|-------------+---------------+-----------+-------|
| 33344455566 | João Jesus    | Projeto B |    20 |
| 11122233344 | José da Silva | Projeto A |    33 |
| 44455566677 | Josuel Santos | Projeto C |    17 |
| 22233344455 | Maria Rosa    | Projeto B |    15 |

* Aula 10C, parte 2: Funções de agregação

Funções de  agregação analisam o  conteúdo de uma coluna,  para várias
linhas, e retornar um determinado resultado.

** Função ~COUNT~

Responsável por  realizar a contagem  do número de linhas  que possuem
conteúdo em  determinada coluna.

O asterisco  analisa linhas  que têm  conteúdo em  pelo menos  uma das
colunas -- em outras palavras, conta  a quantidade de registros em uma
tabela, assumindo que não haja linhas  na tabela onde todas as colunas
estejam em branco.

#+begin_src sql :database empresa
select count(*) from empregado;
#+end_src

#+RESULTS:
| count(*) |
|----------|
|        4 |

Entradas que possuem CPF entre os empregados:

#+begin_src sql :database empresa
select count(cpf) from empregado;
#+end_src

#+RESULTS:
| count(cpf) |
|------------|
|          4 |

O mesmo para valores de departamentos:

#+begin_src sql :database empresa
select count(depto_fk) from empregado;
#+end_src

#+RESULTS:
| count(depto_fk) |
|-----------------|
|               4 |

*** Contagem de elementos distintos

A palavra-chave ~DISTINCT~  força ~COUNT~ a procurar  apenas pelos valores
distintos de ~depto_fk~ na tabela ~empregado~.

#+begin_src sql :database empresa
select count(distinct depto_fk) from empregado;
#+end_src

#+RESULTS:
| count(distinct depto_fk) |
|--------------------------|
|                        3 |

*** Cláusula de critério de agrupamento: ~GROUP BY~

Para cada  valor diferente  da coluna  ~depto_fk~, um  cálculo diferente
será realizado.

Como há três valores diferentes  para a coluna ~depto_fk~, então obterei
três valores diferentes de contagem.

Em  outras palavras,  estamos contando  quantos empregados  diferentes
temos em cada departamento.

#+begin_src sql :database empresa
select count(*) from empregado
group by depto_fk;
#+end_src

#+RESULTS:
| count(*) |
|----------|
|        1 |
|        2 |
|        1 |


Vamos deixar  isso  um pouco  mais  explícito, mostrando  qual
deparatamento é qual.

Ainda melhor  que isso,  renomearemos a  coluna ~count(*)~  do resultado
como ~Total Empregados~.

#+begin_src sql :database empresa
select depto_fk, count(*) as 'Total Empregados'
from empregado
group by depto_fk;
#+end_src

#+RESULTS:
| depto_fk | Total Empregados |
|----------+------------------|
|        1 |                1 |
|        2 |                2 |
|        3 |                1 |

** Usando ~COUNT~ e ~JOIN~ em conjunto

Vamos mostrar o número e o nome  de um departamento, bem como o número
de empregados atualmente registrados em cada departamento.

É  necessário   realizar  o   ~JOIN~,  posto   que  as   informações  de
departamentos pertencem  à tabela ~departamento~; todavia,  as contagens
agrupadas  de   total  de  empregados  estão   relacionadas  à  tabela
~empregado~.

#+begin_src sql :database empresa
select depto_fk, d.nome, count(*) as 'Total Empregados'
from empregado as e
join departamento as d on e.depto_fk = d.numero
group by depto_fk;
#+end_src

#+RESULTS:
| depto_fk | nome             | Total Empregados |
|----------+------------------+------------------|
|        1 | Administração    |                1 |
|        2 | Recursos humanos |                2 |
|        3 | Operação         |                1 |

*** Usando cláusula ~WHERE~

Se quiséssemos  realizar essa consulta para  departamentos cujo número
seja maior que  ~1~, precisaríamos entrar com a cláusula  ~WHERE~ antes do
~GROUP BY~.

#+begin_src sql :database empresa
select depto_fk, d.nome, count(*) as 'Total Empregados'
from empregado as e
join departamento as d on e.depto_fk = d.numero
where depto_fk > 1
group by depto_fk;
#+end_src

#+RESULTS:
| depto_fk | nome             | Total Empregados |
|----------+------------------+------------------|
|        2 | Recursos humanos |                2 |
|        3 | Operação         |                1 |

*** Ordenando resultado pela agregação

Aqui, utilizaremos  um ~ORDER BY~  para ordenar os resultados  de acordo
com o resultado do cálculo da função de agregação.

Note que o nome dado à coluna com o cálculo da função de agregação tem
que estar *entre crases*.

#+begin_src sql :database empresa
select depto_fk, d.nome, count(*) as `Total`
from empregado as e
join departamento as d on e.depto_fk = d.numero
group by depto_fk
order by `Total`;
#+end_src

#+RESULTS:
| depto_fk | nome             | Total |
|----------+------------------+-------|
|        3 | Operação         |     1 |
|        1 | Administração    |     1 |
|        2 | Recursos humanos |     2 |

** Função ~MAX~

Responsável  por  analisar determinados  valores  e  retornar o  valor
máximo dentre esses valores.

A consulta a  seguir retorna o valor máximo de  horas que um empregado
atua em um projeto.

#+begin_src sql :database empresa
select max(horas) from emp_proj;
#+end_src

#+RESULTS:
| max(horas) |
|------------|
|         33 |

** Função ~MIN~

Similar  à ~MAX~,  porém retornando  o  valor mínimo  dentre os  valores
analisados.

A consulta a  seguir retorna o valor mínimo de  horas que um empregado
atua em um projeto.

#+begin_src sql :database empresa
select min(horas) from emp_proj;
#+end_src

#+RESULTS:
| min(horas) |
|------------|
|         15 |

** Função ~AVG~

Responsável  por  calcular  a  *média* de  um  determinado  conjunto  de
valores,  considerando-se  as linhas  de  valores  de uma  determinada
coluna.

A consulta  a seguir retorna  o valor  médio de horas  trabalhadas por
empregados em projetos.

#+begin_src sql :database empresa
select avg(horas) from emp_proj;
#+end_src

#+RESULTS:
| avg(horas) |
|------------|
|      21.25 |

Podemos dar  um resultado melhor  para a consulta anterior  através do
arredondamento da  média das horas, o  que pode ser feito  pela função
~ROUND~.

O exemplo a seguir mostra o valor arredondado com uma casa decimal.

#+begin_src sql :database empresa
select round(avg(horas), 1) from emp_proj;
#+end_src

#+RESULTS:
| round(avg(horas), 1) |
|----------------------|
|                 21.2 |

Igualmente, podemos usar ~GROUP BY~ para agrupar os resultados de acordo
com  o número  do  projeto.  Assim, teremos  o  valor  médio de  horas
trabalhadas por empregados *em cada projeto específico*.

#+begin_src sql :database empresa
select numero, round(avg(horas), 1)
from emp_proj
group by numero;
#+end_src

#+RESULTS:
| numero | round(avg(horas), 1) |
|--------+----------------------|
|      1 |                 33.0 |
|      2 |                 17.5 |
|      3 |                 17.0 |

*Extra:* Vou tentar melhorar um pouco mostrando o nome do projeto.

#+begin_src sql :database empresa
select p.nome, round(avg(horas), 1) as horas_medias
from emp_proj as pj
join projeto as p on pj.numero = p.numero
group by pj.numero;
#+end_src

#+RESULTS:
| nome      | horas_medias |
|-----------+--------------|
| Projeto A |         33.0 |
| Projeto B |         17.5 |
| Projeto C |         17.0 |

*Adaptado da aula:* Agora, vamos ordenar  isso pelo cálculo da função de
 agregação.

#+begin_src sql :database empresa
select p.nome, round(avg(horas), 1) as horas_medias
from emp_proj as pj
join projeto as p on pj.numero = p.numero
group by pj.numero
order by horas_medias;
#+end_src

#+RESULTS:
| nome      | horas_medias |
|-----------+--------------|
| Projeto C |         17.0 |
| Projeto B |         17.5 |
| Projeto A |         33.0 |

*Extra:* E  para projetos com  número de projeto  maior que ~1~?  Eis onde
 entraria a cláusura ~WHERE~.

#+begin_src sql :database empresa
select p.nome, round(avg(horas), 1) as horas_medias
from emp_proj as pj
join projeto as p on pj.numero = p.numero
where pj.numero > 1
group by pj.numero
order by horas_medias;
#+end_src

#+RESULTS:
| nome      | horas_medias |
|-----------+--------------|
| Projeto C |         17.0 |
| Projeto B |         17.5 |

Se fosse uma query um pouco  mais simples, teríamos o ~WHERE~ entre ~FROM~
e ~GROUP BY~:

#+begin_src sql :database empresa
select numero, round(avg(horas), 1) from emp_proj
where numero > 1
group by numero
order by round(avg(horas), 1);
#+end_src

#+RESULTS:
| numero | round(avg(horas), 1) |
|--------+----------------------|
|      3 |                 17.0 |
|      2 |                 17.5 |

** Consulta com predicado envolvendo função de agregação

Quando  a função  de agregação  precisa  ser usada  como predicado  na
seleção dos  valores, onde normalmente pensaria-se  em utilizar ~WHERE~,
utiliza-se ~HAVING~:

#+begin_src sql :database empresa
select numero, round(avg(horas), 2) from emp_proj
group by numero
having round(avg(horas), 2) > 17
order by round(avg(horas), 2);
#+end_src

#+RESULTS:
| numero | round(avg(horas), 2) |
|--------+----------------------|
|      2 |                17.50 |
|      1 |                33.00 |

** Operador ~LIKE~

Realiza pesquisas no banco de dados através de /wildcards/.

A  consulta a  seguir  retorna  todos os  resultados  onde  o nome  do
empregado inicie-se com a letra ~M~, seja ela maiúscula ou minúscula.

#+begin_src sql :database empresa
select * from empregado
where nome like 'm%';
#+end_src

#+RESULTS:
|         cpf | nome       | endereco                      | depto_fk |
|-------------+------------+-------------------------------+----------|
| 22233344455 | Maria Rosa | Rua B, 22, Centro, Diamantina |        2 |

A  próxima  consulta  retorna  todos  os resultados  onde  o  nome  do
empregado inicie-se com  a letra ~J~ (maiúscula ou  minúscula) e termine
com a letra ~S~ (maiúscula ou minúscula).

#+begin_src sql :database empresa
select * from empregado
where nome like 'j%s';
#+end_src

#+RESULTS:
|         cpf | nome          | endereco                             | depto_fk |
|-------------+---------------+--------------------------------------+----------|
| 33344455566 | João Jesus    | Rua D, 15, Palha, Diamantina         |        2 |
| 44455566677 | Josuel Santos | Rua Domingos, 22, Centro, Diamantina |        3 |

Esta consulta agora compara pela quantidade de letras em um nome. Mais
especificamente,  retorna todos  os empregados  cujo nome  utilize dez
caracteres, incluindo espaços.

#+begin_src sql :database empresa
select * from empregado
where nome like '__________';
#+end_src

#+RESULTS:
|         cpf | nome       | endereco                      | depto_fk |
|-------------+------------+-------------------------------+----------|
| 22233344455 | Maria Rosa | Rua B, 22, Centro, Diamantina |        2 |
| 33344455566 | João Jesus | Rua D, 15, Palha, Diamantina  |        2 |

Podemos  também tentar  garantir  que  o nome  tenha  pelo menos  três
caracteres, por exemplo:

#+begin_src sql :database empresa
select * from empregado
where nome like '___%';
#+end_src

#+RESULTS:
|         cpf | nome          | endereco                             | depto_fk |
|-------------+---------------+--------------------------------------+----------|
| 11122233344 | José da Silva | Rua C, 44, Centro, Diamantina        |        1 |
| 22233344455 | Maria Rosa    | Rua B, 22, Centro, Diamantina        |        2 |
| 33344455566 | João Jesus    | Rua D, 15, Palha, Diamantina         |        2 |
| 44455566677 | Josuel Santos | Rua Domingos, 22, Centro, Diamantina |        3 |

Finalmente, procuramos por  um nome que tenha a letra  ~a~ (maiúscula ou
minúscula) como  segundo caractere, com tamanho  indefinido. Em outras
palavras, precisamos  de pelo menos um  caractere, seguido de um  ~a~, e
então um número arbitrário de caracteres:

#+begin_src sql :database empresa
select * from empregado
where nome like '_a%';
#+end_src

#+RESULTS:
|         cpf | nome       | endereco                      | depto_fk |
|-------------+------------+-------------------------------+----------|
| 22233344455 | Maria Rosa | Rua B, 22, Centro, Diamantina |        2 |

* Aula 10D: Atualização e remoção de informações

Esses comandos  precisam ser utilizados  com cuidado! Eles  alteram ou
apagam informações no banco de dados.

** Comando ~UPDATE~

*** Alterando empregados

#+begin_src sql :database empresa
select * from empregado;
#+end_src

#+RESULTS:
|         cpf | nome          | endereco                             | depto_fk |
|-------------+---------------+--------------------------------------+----------|
| 11122233344 | José da Silva | Rua C, 44, Centro, Diamantina        |        1 |
| 22233344455 | Maria Rosa    | Rua B, 22, Centro, Diamantina        |        2 |
| 33344455566 | João Jesus    | Rua D, 15, Palha, Diamantina         |        2 |
| 44455566677 | Josuel Santos | Rua Domingos, 22, Centro, Diamantina |        3 |

Vamos mudar informações de endereço do José da Silva.

#+begin_src sql :database empresa
update empregado
set endereco = 'Rua A, 22, Palha, Diamantina'
where cpf = 11122233344;
#+end_src

#+RESULTS:
|   |

#+begin_src sql :database empresa
select * from empregado where cpf = 11122233344;
#+end_src

#+RESULTS:
|         cpf | nome          | endereco                     | depto_fk |
|-------------+---------------+------------------------------+----------|
| 11122233344 | José da Silva | Rua A, 22, Palha, Diamantina |        1 |

*** Observação
:PROPERTIES:
:UNNUMBERED: t
:END:

*CUIDADO!*  O comando  a  seguir  é um  ~UPDATE~  sem  ~WHERE~. Tal  comando
atualizaria o  endereço de todos  os empregados, de  forma irrestrita,
ocasionando sobrescrita não-intencional de  informações, o que implica
em perda das mesmas.

#+begin_src sql :eval no :tangle no
update empregado
set endereco = 'Rua A, 22, Palha, Diamantina';
#+end_src

*** Alterando departamentos

#+begin_src sql :database empresa
select * from departamento;
#+end_src

#+RESULTS:
| numero | nome             |
|--------+------------------|
|      1 | Administração    |
|      2 | Recursos humanos |
|      3 | Operação         |

Vamos mudar o nome do departamento  de Recursos Humanos para Gestão de
Pessoas.

#+begin_src sql :database empresa
update departamento
set nome = "Gestão de Pessoas"
where numero = 2;
#+end_src

#+RESULTS:
|   |

#+begin_src sql :database empresa
select * from departamento;
#+end_src

#+RESULTS:
| numero | nome              |
|--------+-------------------|
|      1 | Administração     |
|      2 | Gestão de Pessoas |
|      3 | Operação          |

*** Alterando relações entre empregados e projetos

#+begin_src sql :database empresa
select * from emp_proj;
#+end_src

#+RESULTS:
|         cpf | numero | horas |
|-------------+--------+-------|
| 11122233344 |      1 |    33 |
| 22233344455 |      2 |    15 |
| 33344455566 |      2 |    20 |
| 44455566677 |      3 |    17 |

Vamos aumentar  o número  de horas trabalhadas  para quem  trabalha no
projeto número 1, em 10%.

#+begin_src sql :database empresa
update emp_proj
set horas = horas + (horas * 0.10)
where numero = 1;
#+end_src

#+RESULTS:
|   |


#+begin_src sql :database empresa
select * from emp_proj;
#+end_src

#+RESULTS:
|         cpf | numero | horas |
|-------------+--------+-------|
| 11122233344 |      1 |  36.3 |
| 22233344455 |      2 |    15 |
| 33344455566 |      2 |    20 |
| 44455566677 |      3 |    17 |

** Comando ~DELETE~

*** Deletando empregados

**** Preparando o exemplo

#+begin_src sql :database empresa
select * from empregado;
#+end_src

#+RESULTS:
|         cpf | nome          | endereco                             | depto_fk |
|-------------+---------------+--------------------------------------+----------|
| 11122233344 | José da Silva | Rua A, 22, Palha, Diamantina         |        1 |
| 22233344455 | Maria Rosa    | Rua B, 22, Centro, Diamantina        |        2 |
| 33344455566 | João Jesus    | Rua D, 15, Palha, Diamantina         |        2 |
| 44455566677 | Josuel Santos | Rua Domingos, 22, Centro, Diamantina |        3 |

Vamos inserir um novo empregado.

#+begin_src sql :database empresa
insert into empregado(cpf, nome, endereco, depto_fk)
values(99988877765, "Francisco Melo", "Rua F, 43, Centro, Diamantina", 2);
#+end_src

#+RESULTS:
|   |

#+begin_src sql :database empresa
select * from empregado;
#+end_src

#+RESULTS:
|         cpf | nome           | endereco                             | depto_fk |
|-------------+----------------+--------------------------------------+----------|
| 11122233344 | José da Silva  | Rua A, 22, Palha, Diamantina         |        1 |
| 22233344455 | Maria Rosa     | Rua B, 22, Centro, Diamantina        |        2 |
| 33344455566 | João Jesus     | Rua D, 15, Palha, Diamantina         |        2 |
| 44455566677 | Josuel Santos  | Rua Domingos, 22, Centro, Diamantina |        3 |
| 99988877765 | Francisco Melo | Rua F, 43, Centro, Diamantina        |        2 |

**** Efetuando a remoção

#+begin_src sql :database empresa
delete from empregado
where cpf = 99988877765;
#+end_src

#+RESULTS:
|   |

#+begin_src sql :database empresa
select * from empregado;
#+end_src

#+RESULTS:
|         cpf | nome          | endereco                             | depto_fk |
|-------------+---------------+--------------------------------------+----------|
| 11122233344 | José da Silva | Rua A, 22, Palha, Diamantina         |        1 |
| 22233344455 | Maria Rosa    | Rua B, 22, Centro, Diamantina        |        2 |
| 33344455566 | João Jesus    | Rua D, 15, Palha, Diamantina         |        2 |
| 44455566677 | Josuel Santos | Rua Domingos, 22, Centro, Diamantina |        3 |

*** Observação
:PROPERTIES:
:UNNUMBERED: t
:END:

*CUIDADO!*  O comando  a  seguir  é um  ~DELETE~  sem  ~WHERE~. Tal  comando
ocasiona remoção de *todas as informações da tabela*.

#+begin_src sql :eval no :tangle no
delete from empregado;
#+end_src

*** Deletando departamentos (ou pelo menos tentando)

Temos  três  departamentos,  e  existe  uma  relação  entre  a  tabela
~empregado~  e  a  tabela  ~departamento~, posto  que  empregados  estejam
organizados em departamentos.

#+begin_src sql :database empresa
select cpf, e.nome, endereco, d.nome as 'nome_depto'
from empregado as e
join departamento as d on e.depto_fk = d.numero;
#+end_src

#+RESULTS:
|         cpf | nome          | endereco                             | nome_depto        |
|-------------+---------------+--------------------------------------+-------------------|
| 11122233344 | José da Silva | Rua A, 22, Palha, Diamantina         | Administração     |
| 22233344455 | Maria Rosa    | Rua B, 22, Centro, Diamantina        | Gestão de Pessoas |
| 33344455566 | João Jesus    | Rua D, 15, Palha, Diamantina         | Gestão de Pessoas |
| 44455566677 | Josuel Santos | Rua Domingos, 22, Centro, Diamantina | Operação          |

Como existe essa dependência  de empregados para departamentos, tentar
deletar um departamento ocasionará um erro.

#+begin_src sql :eval no :tangle no
delete from departamento where numero = 1; -- Erro!
#+end_src

#+begin_example
ERROR 1451 (23000) at line 1: Cannot delete or update a parent row: a foreign key constraint fails (`empresa`.`empregado`, CONSTRAINT `empregado_ibfk_1` FOREIGN KEY (`depto_fk`) REFERENCES `departamento` (`numero`))
#+end_example

*** Deletando relações empregado x projeto

**** Preparando a tabela da relação

#+begin_src sql :database empresa
select * from emp_proj;
#+end_src

#+RESULTS:
|         cpf | numero | horas |
|-------------+--------+-------|
| 11122233344 |      1 |  36.3 |
| 22233344455 |      2 |    15 |
| 33344455566 |      2 |    20 |
| 44455566677 |      3 |    17 |

Vamos associar o empregado de CPF ~11122233344~ ao projeto ~2~.

#+begin_src sql :database empresa
insert into emp_proj(cpf, numero, horas)
values(11122233344, 2, 13);
#+end_src

#+RESULTS:
|   |

#+begin_src sql :database empresa
select * from emp_proj;
#+end_src

#+RESULTS:
|         cpf | numero | horas |
|-------------+--------+-------|
| 11122233344 |      1 |  36.3 |
| 11122233344 |      2 |    13 |
| 22233344455 |      2 |    15 |
| 33344455566 |      2 |    20 |
| 44455566677 |      3 |    17 |

**** Apagando o registro adicionado

Fazemos  um  ~DELETE~  cuja  condição  envolva  o  CPF  e  o  número  do
projeto.  Do contrário,  se  não informássemos  o  número do  projeto,
acabaríamos  deletando  ambas as  relações  entre  o funcionário  e  o
projeto!  Igualmente, informar  apenas o  número do  projeto deletaria
todos os CPFs associados a tal projeto.

#+begin_src sql :database empresa
delete from emp_proj
where cpf = 11122233344 and numero = 2;
#+end_src

#+RESULTS:
|   |

#+begin_src sql :database empresa
select * from emp_proj;
#+end_src

#+RESULTS:
|         cpf | numero | horas |
|-------------+--------+-------|
| 11122233344 |      1 |  36.3 |
| 22233344455 |      2 |    15 |
| 33344455566 |      2 |    20 |
| 44455566677 |      3 |    17 |

* Formas normais

Auxiliam na redução de redundâncias na base de dados.

** 1FN

Garantir que todos os atributos sejam monovalorados.

Exemplo de tabela que fere esse requisito:

|------+---------+----------+-----------------------------------------|
| CPF  | Nome    | Telefone | Endereço                                |
|------+---------+----------+-----------------------------------------|
| XXXX | Fulano  | 12345,   | Rua A, 25, Bairro X, Cidade Y, Estado Z |
|      |         | 67890    |                                         |
|------+---------+----------+-----------------------------------------|
| YYYY | Ciclano | 98765,   | Rua B, 33, Bairro X, Cidade Y, Estado Z |
|      |         | 76543    |                                         |
|------+---------+----------+-----------------------------------------|

- Telefone é multivalorado.
- Poderíamos considerar endereço como multivalorado também, dependendo
  das regras de negócio.

  Solução: Adicione mais colunas na tabela.

** 2FN

Eliminar   dependências    funcionais   parciais,    deixando   apenas
dependências funcionais totais.

Exemplo  de tabela  que fere  esse  requisito (Considere  que a  chave
composta ~{cod_disciplina, turno}~ e que ~carga_horaria~ depende apenas de
~cod_disciplina~ (parte da chave):

Tabela Turma
| cod_disciplina (PK) | turno (PK) | cpf_professor | carga_horaria |
|---------------------+------------+---------------+---------------|
| COM015              |          1 |         12345 |            60 |
| COM015              |          2 |           321 |            60 |
| COM001              |          1 |          7593 |            75 |
| COM002              |          1 |        601274 |            60 |

Redundância no  armazenamento de  ~carga_horaria~, que  é funcionalmente
dependente de ~cod_disciplina~.

Solução:  Quebrar  esta  tabela  em duas;  ~cod_disciplina~  será  chave
primária da outra tabela.

Tabela Turma
| cod_disciplina (PK) | turno (PK) | cpf_professor |
|---------------------+------------+---------------|
| COM015              |          1 |         12345 |
| COM015              |          2 |           321 |
| COM001              |          1 |          7593 |
| COM002              |          1 |        601274 |

Tabela Disciplina
| cod_disciplina (PK) | carga_horaria |
|---------------------+---------------|
| COM015              |            60 |
| COM015              |            60 |
| COM001              |            75 |
| COM002              |            60 |

** 3FN

Garantir que não existam dependências funcionais transitivas.

Exemplo  de  tabela que  fere  esse  requisito (Considere  que  ~codigo~
determina  ~tipo~ do  produto,  que portanto  determina ~icms~.  Portanto,
~codigo~ define ~icms~ transitivamente):

| codigo (PK) | nome         | quantidade | tipo        | icms |
|-------------+--------------+------------+-------------+------|
|         123 | Sabão em Pó  |        100 | Limpeza     | 0,02 |
|         456 | Detergente   |        150 | Limpeza     | 0,02 |
|         789 | Arroz        |         89 | Alimentício | 0,01 |
|         888 | Feijão       |         22 | Alimentício | 0,01 |
|         898 | Vinho Canção |        100 | Bebida      | 0,05 |

Redundância de armazenamento  de ~icms~, que é determinado  pelo ~tipo~ do
produto, e que é inerente ao ~codigo~ do produto (chave).

Solução: Quebrar  esta tabela  em duas;  o ~tipo~ passa  a ser  chave da
segunda tabela, e passa a ser chave estrangeira na primeira tabela.

Tabela Produto
| codigo | nome         | quantidade | tipo (FK)   |
|--------+--------------+------------+-------------|
|    123 | Sabão em Pó  |        100 | Limpeza     |
|    456 | Detergente   |        150 | Limpeza     |
|    789 | Arroz        |         89 | Alimentício |
|    888 | Feijão       |         22 | Alimentício |
|    898 | Vinho Canção |        100 | Bebida      |

Tabela Taxa_Imposto
| tipo (PK)   | icms |
|-------------+------|
| Limpeza     | 0,02 |
| Limpeza     | 0,02 |
| Alimentício | 0,01 |
| Alimentício | 0,01 |
| Bebida      | 0,05 |

