#+title: CD-ROM Access

* CD-ROM Basics

So far, all the data we've been using is in our executable.

- We need more than 2MB of RAM for executable and assets.
- We need images, textures, 3D mesh data, audio, etc.

The PlayStation allows CD-ROM with up to 650 MB of information.

The CD-ROM has sections and sectors, but it is also divided in areas such as the
lead-in area, table of Content (TOC), and lead-out area.

Hard  drives  are  magnetic  disks,  so   they  use  magnetic  forces  to  store
information (repulsion and attraction are 1's and 0's).

The  CD-ROM, though,  is  optic media,  so  it'll  either have  a  scratch or  a
reflection simbolizing 0's and 1's.

** Rainbow books

The rainbow books are a collection of CD format specifications generally written
and published by standards bodies including the ISO, IEC, and ECMA.

| Kind   | Color   | Year | Description               |
|--------+---------+------+---------------------------|
| CD-DA  | Red     | 1980 | Digital Audio             |
| CD-ROM | Yellow  | 1983 | Read-Only Memory          |
| CD-I   | Green   | 1986 | Interactive               |
| CD-RW  | Orange  | 1990 | Recordable & Rewritable   |
| PCD    | Beige   | 1992 | Photo CD                  |
| VCD    | White   | 1993 | Video CD & Super Video CD |
| E-CD   | Blue    | 1995 | Enhanced                  |
| SA-CD  | Scarlet | 1999 | Super Audio               |
| DD-CD  | Purple  | 2000 | Double Density            |

Source: [[https://en.wikipedia.org/wiki/Rainbow_Books][Wikipedia]]

** Data tracks

#+begin_example
CD
└─ Section 1
   └─ Track 1
      ├─ TEXTURES
      │  └─ GRASS.TIM
      └─ MODELS
         ├─ CUBE.OBJ
         └─ FLOOR.OBJ
#+end_example

- PlayStation CDs are  made up of small data blocks  called *sectors*, each 2048
  bytes long.
- Sectors are grouped in *tracks* (either data or audio), and tracks are grouped
  into *sections*.
- PS1 disks _usually_ contain one single data track.
- Data track information is organized using the standard filesystem *ISO-9660*.

** ISO generation with 32-bit toolchain

For ISO generation on  32-bit contexts (Windows XP preferably), we  use a set of
three tools.

*** ~BUILDCD.EXE~

Generates ~GAME.IMG~ image from ~CDLAYOUT.CTI~. Here is an example of this file:

#+begin_src conf
Define GameName "MyGame"
Define GameDir .
Disc CDROMXA_PSX
  CatalogNumber 0000000000000
  Leadin XA
    Empty 300
    PostGap 150
  EndTrack

  Track XA
    Pause 150
    Volume ISO9660
      SystemArea .\LCNSFILE\LICENSEE.DAT
      PrimaryVolume
        SystemIdentifier "PLAYSTATION"
        VolumeIdentifier [GameName]
        VolumeSetIdentifier [GameName]
        PublisherIdentifier "SCEE"
        DataPreparerIdentifier "SONY"
        ApplicationIdentifier "PLAYSTATION"
        LPath
        OptionalLpath
        MPath
        OptionalMpath

        Hierarchy
          XAFileAttributes  Form1 Audio
          XAVideoAttributes ApplicationSpecific
          XAAudioAttributes ADPCM_C Stereo

          File SYSTEM.CNF
            XAFileAttributes Form1 Data
            Source [GameDir]\SYSTEM.TXT
          EndFile

          File MAIN.EXE
            XAFileAttributes Form1 Data
            Source [GameDir]\MAIN.EXE
          EndFile

          File CUBE.OBJ
            XAFileAttributes Form1 Data
            Source [GameDir]\CUBE.OBJ
          EndFile
        EndHierarchy
      EndPrimaryVolume
    EndVolume
  EndTrack
EndDisk
#+end_src

*** ~PSXLICENSE.EXE~

Bundles the Sony license ~LICENSEE.DAT~ into CD image file.

*** ~STRIPISO.EXE~

Generate ~ISO~ file ~GAME.ISO~ from ~GAME.IMG~.

*** Utility BAT file

We would  probably have  to create  a ~BUILDISO.BAT~  helper file  somewhat like
this:

#+begin_src bat
@ECHO OFF

ECHO Compiling and generating executable...
psymake

ECHO Building IMG file...
BUILDCD -l -iGAME.IMG CDLAYOUT.CTI

ECHO Converting GAME.IMG to GAME.ISO...
STRIPISO S 2352 GAME.IMG GAME.ISO

ECHO Bundling license to game ISO...
PSXLICENSE /eu /i GAME.ISO

ECHO The ISO file was built successfully!
#+end_src

* Generating an ISO on Windows XP

We're  going  to   build  a  new  project  that  we're   going  to  create  from
scratch. It'll  be called ~hellocd~.  I simply copied  everything -- and  I also
created the ~Cube~ and ~Floor~ structs just to be 1:1 with the course project.

Instead of  encoding vertices and  faces on our project  code files, we  want to
have more dynamic stuff. So we're gonna make these data external, as data files.

On Windows XP, let's start by adding our ~CDTOOLS~ to the Path.

** CD-ROM building files

Now, let's add important files to our  directory. The files are:

- ~LCNSFILE/LICENSEE.DAT~: Sony License file. I'm  not going to provide it here,
  I'm sorry. It used to be redistributed along with the original Psy-Q SDK.
- ~assets/model.bin~: Model data file.
- ~SYSTEM.TXT~: CD-ROM configuration variables.
- ~CDLAYOUT.CTI~:

*** ~SYSTEM.TXT~

These are the configurations for booting the CD-ROM.

#+begin_src ini :tangle c/hellocd/SYSTEM.TXT
BOOT=cdrom:\MAIN.EXE;1
TCB=4
EVENT=10
STACK=801FFFF0
#+end_src

*** ~CDLAYOUT.CTI~

These  are the  configurations for  building  the CD-ROM  image, licensing,  and
ISO9660 filesystem configuration.

#+begin_src conf :tangle c/hellocd/CDLAYOUT.CTI
Define GameName "Game"
Define GameDir .

Disc CDROMXA_PSX
  CatalogNumber 0000000000000

  Leadin XA
    Empty 300
    PostGap 150
  EndTrack

  Track XA
    Pause 150
    Volume ISO9660
      SystemArea .\LCNSFILE\LICENSEE.DAT

      PrimaryVolume
        SystemIdentifier "PLAYSTATION"
        VolumeIdentifier [GameName]
        VolumeSetIdentifier [GameName]
        PublisherIdentifier "SCEE"
        DataPreparerIdentifier "SONY"
        ApplicationIdentifier "PLAYSTATION"
        LPath
        OptionalLpath
        MPath
        OptionalMpath

        Hierarchy
          XAFileAttributes  Form1 Audio
          XAVideoAttributes ApplicationSpecific
          XAAudioAttributes ADPCM_C Stereo

          File SYSTEM.CNF
            XAFileAttributes Form1 Data
            Source [GameDir]\SYSTEM.TXT
          EndFile

          File MAIN.EXE
            XAFileAttributes Form1 Data
            Source [GameDir]\MAIN.EXE
          EndFile

          File MODEL.BIN
            XAFileAttributes Form1 Data
            Source [GameDir]\assets\MODEL.BIN
          EndFile
        EndHierarchy
      EndPrimaryVolume
    EndVolume
  EndTrack
EndDisk
#+end_src

** Generating ISO

Provided that the  toolchain binaries are on  your PATH, this is  easy. Just use
the following ~BUILDISO.BAT~ file to build the project and also build the ISO:

#+begin_src bat c/hellocd/BUILDISO.BAT
@ECHO OFF
psymake
BUILDCD -l -iGAME.IMG CDLAYOUT.CTI
STRIPISO S 2352 GAME.IMG GAME.ISO
PSXLICENSE /eu /i GAME.ISO
#+end_src

** The filesystem

On No$psx, go to Window > Filesystem. There,  you should be able to see that the
CD-ROM drive has  a single track (Track 01) of  data, containing three important
files: ~SYSTEM.CNF~, ~MAIN.EXE~ and ~MODEL.BIN~.

There is also going to be a ~License.txt~ file and a ~Logo.tmd~ file.

There  would also  be  a final  dummy  track  (Track AA),  which  is the  CD-ROM
lead-out.

* Generating an ISO on Windows 11

If you're using a modern Windows 11 machine, there is also a way to generate the
ISO.

Make sure you already have the ~assets/model.bin~ and ~SYSTEM.TXT~ files.

You'll also need to download [[https://github.com/Lameguy64/mkpsxiso][~mkpsxiso~]] and install it to your path.

In the  case of  the modern  toolchain, we  are going  to have  a ~CDLAYOUT.xml~
file. It has  basically the same idea as ~CDLAYOUT.CTI~,  except we're declaring
it as a XML format for a different tool that builds our CD.

#+begin_src xml :tangle c/hellocd/CDLAYOUT.xml
<?xml version="1.0" encoding="UTF-8"?>
<iso_project image_name="GAME.ISO" cue_sheet="GAME.CUE" no_xa="0">
  <track type="data">
    <identifiers
	system        = "PLAYSTATION"
	application   = "PLAYSTATION"
	volume        = "MYDISC"
	volume_set    = "GAME"
	publisher     = "ME"
	data_preparer = "MKPSXISO"
	copyright     = "COPYLEFT" />
    <license file="LCNSFILE/LICENSEE.DAT" />
    <directory_tree>
      <file name="SYSTEM.CNF" type="data" source="SYSTEM.TXT" />
      <file name="MAIN.EXE" type="data" source="hellocd.ps-exe" />
      <file name="MODEL.BIN" type="data" source="assets/model.bin" />
    </directory_tree>
  </track>
</iso_project>
#+end_src

Now just run ~mkpsxiso~:

#+begin_src powershell
mkpsxiso CDLAYOUT.xml
#+end_src

** Using the ISO with PCSX-Redux

After you  build the ISO image  for the first time,  think of it as  a read-only
storage for our asset files. You can run the ISO image on PCSX-Redux no problem,
but if you still  want to be able to debug your application  like you were doing
before,  first load  the  image, then  just  press  ~F5~ on  VSCode  to run  the
~.ps-exe~ directly from your machine.

* Generating the project using Docker

I took  the liberty of  creating a Docker  project containing the  toolchain for
building  these. The  Docker image  contains  both the  GCC-MIPSEL compiler  and
mkpsxiso.

The Dockerfile for the toolchain can be found [[https://github.com/luksamuk/psxtoolchain][here]].

#+begin_src bash :tangle c/hellocd/buildiso.sh
#!/bin/bash
exec docker run --rm \
     -v $(pwd):/source \
     -w /source \
     luksamuk/psxtoolchain:latest \
     "make && mkpsxiso -y CDLAYOUT.xml"
#+end_src

* What is ~SYSTEM.CNF~?

This file is basically an ASCII ~.txt~ containing boot information for the disc,
analogous to ~AUTOEXEC.BAT~ or ~CONFIG.SYS~ on old MS-DOS.

The parameters provided are:

- ~BOOT=cdrom:\MAIN.EXE;1~: tells  the main boot executable  (~;1~ specifies its
  version, a filesystem property).
- ~TCB=4~: provides information  about Thread Control Blocks  (maximum number of
  threads).
- ~EVENT=10~: provides information about Event Control Blocks (maximum number of
  events).
- ~STACK=801FFFF0~: tells the system where to initialize the stack pointer.

If needed be, [[https://problemkaputt.de/psxspx-cdrom-file-playstation-exe-and-system-cnf.htm][check the documentation on psx-spx]].

* A Function to Read Files from the CD

Now, we wish to have a function named ~file_read~ that could work like this:

#+begin_src c
u_long length;
char *bytes;
bytes = (char*) file_read("\\MODEL.BIN;1", &length);
#+end_src

Notice that these bytes will be allocated on the *heap*.

** Function definition

Here's how this function should be declared:

#+begin_src c
char *
file_read(char *filename, u_long *length)
{
    CdlFILE filepos;
    int numsectors;
    char *buffer;

    buffer = NULL;

    // Find file on CD
    if(CdSearchFile(&filepos, filename) == NULL) {
        printf("File %s not found on the CD.\n", filename);
        return NULL;
    }

    // Compute number of sectors to read from the CD
    numsectors = (filepos.size + 2047) / 2048;
    // Allocate buffer for file (must be a multiple of 2048)
    buffer = (char*) malloc(2048 * numsectors);

    if(!buffer) {
        printf("Error allocating %d sectors.\n", numsectors);
        return NULL;
    }

    // Set read target to the file position on the CD
    CdControl(CdlSetloc, (u_char*) &filepos.pos, 0);
    // Start reading from CD (at full speed)
    CdRead(numsectors, (u_long*) buffer, CdlModeSpeed);
    // Wait until the reading is complete
    CdReadSync(0, 0);

    // Return length of the number of bytes read and a buffer pointer
    ,*length = filepos.size;
    return buffer;
}
#+end_src

There are a few Psy-Q specific functions  and data types that we need to invoke,
and they come from ~libcd.h~.

We would also need to initialize the  CD subsystem using ~CdInit()~, and then we
can start reading files from the CD.

** Creating the code

Create a file ~utils.h~ and declare the function prototype.

Create also a ~utils.c~  file (remember to add it to the  Makefile) and copy the
function there.

Since we're using a  modern stack, we also need to initialize  the heap, or else
we won't be able to use the ~malloc~ function. We'll see that soon.

Include ~utils.h~ on ~main.c~. Then, on ~setup~, add the following:

#+begin_src c
CdInit();
#+end_src

** Reading the file

Directly on ~setup~, read the file:

#+begin_src c
char *buffer;
u_long length;

buffer = file_read("\\MODEL.BIN;1", &length);
printf("Read %lu bytes from MODEL.BIN (ptr %p)\n", length, buffer);

free(buffer);
#+end_src

* CD-ROM Access via BIOS Functions

There are already some BIOS functions for accessing the CD-ROM subsystem.

These can be seen on the BIOS functions documentation. There are [[https://psx-spx.consoledev.net/kernelbios/#bios-cdrom-functions][CD-ROM
functions]].

There are also [[https://psx-spx.consoledev.net/kernelbios/#bios-file-functions][File functions]] such as ~open~, ~lseek~, ~read~, ~write~, ~close~,
etc.

CD-ROMs are basically accessed via normal  BIOS file functions, under the device
name ~cdrom0:~.

You can also visit the [[https://psx-spx.consoledev.net/kernelbios/#bios-function-summary][BIOS Function Summary]] to see a list of all functions.

* Understanding the ~MODEL.BIN~ File

Let's take a look at ~MODEL.BIN~.

#+begin_src bash :eval never :tangle no
xxd c/hellocd/assets/model.bin
#+end_src

#+begin_example
00000000: 0008 ff80 ff80 ff80 0080 ff80 ff80 0080  ................
00000010: ff80 0080 ff80 ff80 0080 ff80 0080 ff80  ................
00000020: 0080 0080 ff80 0080 0080 0080 ff80 0080  ................
00000030: 0080 0006 0003 0002 0000 0001 0000 0001  ................
00000040: 0004 0005 0004 0005 0007 0006 0001 0002  ................
00000050: 0005 0006 0002 0003 0006 0007 0003 0000  ................
00000060: 0007 0004 06ff 0000 0000 ff00 0000 00ff  ................
00000070: 00ff 00ff 00ff ff00 0000 ffff 00         .............
#+end_example

Here is the relation for the bytes sequentially:

| Description            | Size                                       |
|------------------------+--------------------------------------------|
| Number of vertices     | 2 bytes                                    |
| X, Y, Z                | 6 bytes per vertex (2 bytes per component) |
| Number of face indices | 2 bytes                                    |
| Face indices           | 8 bytes per face (4 shorts per index)      |
| Number of color faces  | 1 byte                                     |
| Colors                 | 4 bytes per color (R, G, B + padding)      |

So we have:

- 2 bytes containing the number of vertices (8)

#+begin_example
00000000: 0008
00000010:
00000020:
00000030:
00000040:
00000050:
00000060:
00000070:
#+end_example

- 48 bytes of vertex data (2 bytes x 3 components x 8 vertices)
  - We  can notice  that a  ~short~ starting  with ~ff~  is probably  a negative
    number

#+begin_example
00000000:      ff80 ff80 ff80 0080 ff80 ff80 0080
00000010: ff80 0080 ff80 ff80 0080 ff80 0080 ff80
00000020: 0080 0080 ff80 0080 0080 0080 ff80 0080
00000030: 0080
00000040:
00000050:
00000060:
00000070:
#+end_example

- 2 bytes containing the number of faces (6)

#+begin_example
00000000:
00000010:
00000020:
00000030:      0006
00000040:
00000050:
00000060:
00000070:
#+end_example
  
- 48 bytes of face data (2 bytes x 4 face indices x 6 faces)

#+begin_example
00000000:
00000010:
00000020:
00000030:           0003 0002 0000 0001 0000 0001
00000040: 0004 0005 0004 0005 0007 0006 0001 0002
00000050: 0005 0006 0002 0003 0006 0007 0003 0000
00000060: 0007 0004
00000070:
#+end_example

- 1 byte containing the number of colors (6, like the number of faces)

#+begin_example
00000000:
00000010:
00000020:
00000030:
00000040:
00000050:
00000060:           06
00000070:
#+end_example
  
- 24 bytes of color data (1 byte x 4 components including padding x 6 colors)

#+begin_example
00000000:
00000010:
00000020:
00000030:
00000040:
00000050:
00000060:             ff 0000 0000 ff00 0000 00ff
00000070: 00ff 00ff 00ff ff00 0000 ffff 00
#+end_example

* Dynamically Allocating Buffers

First things first, remove the floor, the cube movement and its collision. Let's
keep things simple.

Let's define a new data type called ~Object~:

#+begin_src c
typedef struct Object {
    short numverts;
    SVECTOR *vertices;

    short numfaces;
    short *faces;

    short numcolors;
    CVECTOR *colors;
} Object;
#+end_src

We do not know at compile-time how  many vertices we'll need to store inside the
3D object, so  this is only known at  runtime after we read the  contents of our
file.

We're going to declare a global variable, allocate the vertices on the heap, and
then define them.

* Heap Initialization on Windows 11

Since  we're using  Nugget, we  have to  initialize the  heap, since  Nugget, by
default, does not initialize the heap and the stack by default.

Include the ~malloc.h~ header from Nugget.

#+begin_src c
#include <malloc.h>
#+end_src

Declare the following globals on ~main.c~:

#+begin_src c
extern char __heap_start, __sp;
#+end_src

Now, on ~setup~, initialize the heap and the stack:

#+begin_src c
InitHeap3((unsigned long *) (&__heap_start), (&__sp - 0x5000) - &__heap_start);
#+end_src

With this, we're  setting the size of our stack  (20480 bytes), and initializing
our heap.

Furthermore, *anytime* we use ~malloc~, we'll need to replace it with ~malloc3~.

#+begin_src c
// In utils.c...
buffer = (char*) malloc3(2048 * numsectors);
#+end_src

You should not be able to see any results of ~printf~ with the log window (Debug
> Show Logs).

* Interpreting Bytes as Numbers

* Handling Different Order of Bytes

* Reading Vertices & Faces from a File

