#+title: Audio System
#+startup: content

* Audio & SPU

Ken Kutaragi was once involved in  creating sound chips for Nintendo, and helped
design the Super Nintendo sound chip.

Therefore,  it is  not  surprising  that the  PlayStation  is  a powerful  audio
machine.

And at the center of the stage, there is the SPU.

The  *Sound  Processing Unit*  (SPU)  is  a  crucial component  responsible  for
handling  all   audio-related  tasks,   such  as  frequency   modulation,  pitch
modulation, reverb, loop, playing audio samples, etc.

It  is ultimately  a  device which  takes digital  signals  and transform  these
signals into output that will be played by the TV speaker.

The  SPU  also  has  a  little  buffer,  512KB  of  DRAM,  our  so-called  sound
memory. This is not a lot, but we're gonna make good use of it.

** SPU Specs

- *24 channels* of 16-bit *ADPCM* samples;
  - ADPCM is a way to encode and compress samples.
- Sampling rate of 44.1KHz (audio CD quality);
- The SPU chip also provides:
  - Pitch modulation;
  - Frequency modulation;
  - ADSR envelope (attack, decay, sustain, release);
    - [[https://www.youtube.com/watch?v=aitRs893ado][Here is a very cool and visual video on this subject]].
  - Looping;
  - Digital reverb.

** Samples

We can  also use one of  the channels to play  samples too; each channel  can be
matched  to  a  "voice".  Each  channel  playing  a  sample  would  be  a  voice
channel. These samples are encoded with ADPCM format.

There are two types of ADPCM samples:

1. XA-ADPCM
   - Decompressed by the CD-ROM controller.
   - Is sent directly to the sound mixer.
   - Does *not* require SPU DRAM memory.
   - Does *not* support looping.
   - Only 2 sample rate options.
2. SPU-ADPCM
   - Supports looping and reverb.
   - It needs SPU DRAM memory for storage.
   - VAG and VAB file formats.

** PCM vs. ADPCM

PCM  stands for  *Pulse Code  Modulation*. When  talking about  raw PCM,  we are
talking about  /purely uncompressed  audio/; the original  pure audio  signal is
sampled and stored as-is. The greater  the frequency (amount of samples per time
unit --  the sample rate),  the higher the  resolution. Most ~.WAV~  formats use
basically PCM directly like this.

ADPCM stands for  *Adaptive Differential Pulse Code Modulation*.  It encodes and
/compresses/   16-bit  audio   samples  using   only  *4   bits*  (approximately
$\frac{1}{4}$ data compression). It also  uses prediction, based on the analysis
of the  *difference* of previous  values (instead  of recording input  as-is, we
base on  the difference between  previous and next  sample to estimate  the next
sample). These  are normally stored  on ~.VAG~  files and used  by PlayStation's
SPU-ADPCM; therefore they need to be stored on DRAM memory to be played.

* Converting WAV to VAG

Copy the provided course sound files to ~ASSETS/SOUND~.

This folder contains pure .WAV sound effects from the original Wipeout.

On the Psy-Q library binaries, there is a tool called ~VAGedit~.

To convert  a ~.WAV~ file  using ~VAGedit~, simply  open the file  on ~VAGedit~,
then click "Save".

Now add the ~POWERUP.VAG~ file to our project. No need to add it to any subdir:

#+begin_src fundamental
          File POWERUP.VAG
            XaFileAttributes Form1 Data
            Source [GameDir]\ASSETS\SOUND\POWERUP.VAG
          EndFile
#+end_src

** Converting WAV to VAG... for Linux users

Simply use my Dockerfile, hehe.

Here is a  bash script for converting all files  on the ~ASSETS/SOUND~ directory
to ~.VAG~.

#+begin_src bash
# First open the root directory using the container...
docker run -it --rm -v $(pwd):/source -w /source luksamuk/psxtoolchain:latest /bin/bash

# Now run the following loop
for f in ASSETS/SOUND/*.WAV; do wav2vag "$f" "${f%%.WAV}.VAG"; done
#+end_src

Now add the ~POWERUP.VAG~ file:

#+begin_src xml
<file name="POWERUP.VAG" type="data" source="ASSETS/SOUND/POWERUP.VAG" />
#+end_src

** Creating code files

Create files ~sound.h~ and ~sound.c~.

#+begin_src c
#ifndef SOUND_H
#define SOUND_H

#include <sys/types.h>
#include <libspu.h>

void   sound_init(void);
u_char *load_vag_sound(char *filename, u_long *length);
void   transfer_vag_to_spu(u_char *data, u_long length, int voicechannel);

void audio_play(int voicechannel);
void audio_free(u_long address);
#endif
#+end_src

Let's go ahead and implement our functions.

#+begin_src c
#include "sound.h"

void
sound_init(void)
{
    // TODO
}

u_char *
load_vag_sound(char *filename, u_long *length)
{
    // TODO
}

void
transfer_vag_to_spu(u_char *data, u_long length, int voicechannel)
{
    // TODO
}

void
audio_play(int voicechannel)
{
    // TODO
}

void
audio_free(u_long address)
{
    // TODO
}
#+end_src

** Playing a sound

Now let's go to ~main.c~ and plan what we want to do:

#+begin_src c
#include "sound.h"

// In setup function
// ...
// TODO: Load a VAG file from disk
// TODO: Transfer VAG data to SPU and play it in one of the channels
#+end_src

** Note

I was importing ~libspu.h~ on ~main.c~  and calling ~SpuInit~ on ~setup~ just so
we could stop the BIOS humming when the game loads. I removed that.

* Playing a VAG Sound Effect

We go back to ~sound.c~ and start by implementing the routines to initialize and
load a VAG sound from disk.

#+begin_src c
#include "utils.h"
#include <stdio.h>
#include <stdlib.h>

void
sound_init(void)
{
    SpuInit();

    // TODO: allocate sound memory
    // TODO: configure common settings of the SPU
}

u_char *
load_vag_sound(char *filename, u_long *length)
{
    u_long i;
    u_char *bytes;
    bytes = (u_char *)file_read(filename, length);
    if(bytes == NULL) {
        printf("Error reading %s from the CD.\n", filename);
        return NULL;
    }

    return bytes;
}

// ...
#+end_src

Now back  to ~main.c~.  Create a ~sfx~  global pointer and  then load  the sound
effect:

#+begin_src c
u_char *sfx;

// In setup function
sound_init();

// ...

u_long sfxlength;

// ...

sfx = load_vag_sound("\\POWERUP.VAG;1", &sfxlength);
transfer_vag_to_spu(sfx + 48, sfxlength, SPU_0CH);
#+end_src

** Initializing the SPU

We need to set up the SPU allocator and also setup volume and etc. So we go back
to ~sound.c~.

#+begin_src c
// ...

#define SOUND_MALLOC_MAX 10

static SpuCommonAttr spucommonattr;
static SpuVoiceAttr  spuvoiceattr;

static u_long vagspuaddr;
static char spumallocrec[SPU_MALLOC_RECSIZ * (SOUND_MALLOC_MAX + 1)];

void
sound_init(void)
{
    SpuInit();

    // Allocate sound memory
    SpuInitMalloc(SOUND_MALLOC_MAX, spumallocrec);

    // Configure common settings of the SPU
    spucommonattr.mask = (SPU_COMMON_MVOLL |
                          SPU_COMMON_MVOLR |
                          SPU_COMMON_CDVOLL |
                          SPU_COMMON_CDVOLR |
                          SPU_COMMON_CDMIX);

    spucommonattr.mvol.left  = 0x3fff; // Master volume (left) - 0x0000 ~ 0x3fff
    spucommonattr.mvol.right = 0x3fff; // Master volume (right) - 0x0000 ~ 0x3fff

    spucommonattr.cd.volume.left  = 0x7fff; // CD volume (left) - 0x0000 ~ 0x7fff
    spucommonattr.cd.volume.right = 0x7fff; // CD volume (right) - 0x0000 ~ 0x7fff

    spucommonattr.cd.mix = SPU_ON; // enable CD playback

    SpuSetCommonAttr(&spucommonattr);
}

// ...
#+end_src

We don't really need to setup anything related to CD playback right now, we only
need to set up the master volume.

But  as it  can  be seen  here,  we  basically use  ~spumallocrec~  as a  buffer
containing  audio  data   that  will  be  sent  and  stored   on  the  SPU,  and
~SOUND_MALLOC_MAX~ determines the number of maximum sounds we are going to store
on  the   SPU  --   therefore,  a  maximum   number  of   allocations.  Finally,
~SpuSetCommonAttr~ commits the changes.

** Transfering data to the SPU

We now implement the function which transfer our ~.VAG~ file to the SPU.

Still in ~sound.c~, do this:

#+begin_src c
void
transfer_vag_to_spu(u_char *data, u_long length, int voicechannel)
{
    SpuSetTransferMode(SpuTransByDMA);
    vagspuaddr = SpuMalloc(length);
    SpuSetTransferStartAddr(vagspuaddr);

    SpuWrite(data, length);
    SpuIsTransferCompleted(SPU_TRANSFER_WAIT);

    spuvoiceattr.mask = (SPU_VOICE_VOLR |
                         SPU_VOICE_PITCH |
                         SPU_VOICE_WDSA |
                         SPU_VOICE_ADSR_AMODE |
                         SPU_VOICE_ADSR_SMODE |
                         SPU_VOICE_ADSR_RMODE |
                         SPU_VOICE_ADSR_AR |
                         SPU_VOICE_ADSR_DR |
                         SPU_VOICE_ADSR_SR |
                         SPU_VOICE_ADSR_RR |
                         SPU_VOICE_ADSR_SL);

    spuvoiceattr.voice        = voicechannel;         // Voice channel
    spuvoiceattr.volume.left  = 0x1fff;               // left volume
    spuvoiceattr.volume.right = 0x1fff;               // right volume
    spuvoiceattr.pitch        = 0x1000;               // Pitch
    spuvoiceattr.addr         = vagspuaddr;           // Waveform data start address
    spuvoiceattr.a_mode       = SPU_VOICE_LINEARIncN; // Attack curve
    spuvoiceattr.s_mode       = SPU_VOICE_LINEARIncN; // Sustain curve
    spuvoiceattr.r_mode       = SPU_VOICE_LINEARIncN; // Release curve curve
    spuvoiceattr.ar           = 0x00;                 // Attack rate
    spuvoiceattr.dr           = 0x00;                 // Decay rate
    spuvoiceattr.sr           = 0x00;                 // Sustain rate
    spuvoiceattr.rr           = 0x00;                 // Release rate
    spuvoiceattr.sl           = 0x00;                 // Sustain level

    SpuSetVoiceAttr(&spuvoiceattr);
}
#+end_src

First things first, we deal with transferring data to the SPU. So we set the DMA
to perform the transfer to SPU for us, then we perform an SPU memory allocation,
retrieving the address  of the allocated space  on the SPU. We then  set the SPU
destination address to that address we just allocated.

Following, we take  the pointer of our  waveform data and its  length and simply
write that data to the SPU. The process is asynchronous, so we also need to wait
until the transfer is complete.

Now we just set some attributes to the voice: the voice channel index (passed by
parameter), left  and right volume, pitch,  the pointer to the  beginning of our
waveform   data   on    the   SPU,   and   then    ADSR   envelope   parameters:
attack/sustain/release  modes (in  this  case, linear  incrementation); rate  of
attack, decay, sustain and release; and the sustain level.

Finally, we commit these changes to the SPU.

** Playing the audio

Now all we need to do is implement our playback and freeing functions. These are
very easy and straightforward:

#+begin_src c
void
audio_play(int voicechannel)
{
    SpuSetKey(SpuOn, voicechannel);
}

void
audio_free(u_long address)
{
    SpuFree(address);
}
#+end_src


Now back on ~main.c~, after transfering the VAG file to SPU:

#+begin_src c
// On setup function
// ...
audio_play(SPU_0CH);
#+end_src

* Bits & Sound

* Pitch & Sampling Frequency
* VAG Header Information
* Exercise: Countdown Audio
* Countdown Sound Effects
* Background Music
* Recording an Audio Track
* Adding Audio Track to ISO
* Play Audio Track Implementation
* Play Background Audio Track
* Adding Scene Objects & Audio
