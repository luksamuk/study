#+title: Rendering Polygons
#+startup: content
#+property: header-args:asm :tangle exercises/src/trianglesub.s

The previous topics of this chapter chan be seen on the [[./hello-gpu.org][Hello GPU]] exercise.

* Gouraud-Shading in Games

Gouraud-Shading was very important for the 5th generation of consoles.

This kind  of shading means  we have diferent color  values per vertex,  and the
pixels inbetween have  their colors interpolated by the GPU,  achieving a smooth
shading effect.

It  is  one  of the  most  powerful  techniques  for  the consoles  of  the  5th
generation, being used extensively on games for the PlayStation and Nintendo 64.

A nice example is *Mario's model on Nintendo 64*. Textures are used for the eyes
and some  details such  as buttons or  the M on  the hat,  but the rest  is just
polygons with Gouraud shading. This allowed for the developers to avoid textures
altogether in most part of the model.

People normally know about this technique but  does not know its name (it was my
case).  Used correctly,  this technique  helps developers  overcome the  texture
limitations of early 3D consoles.

An interesting article on porting Gouraud shading of Sonic R from Sega Saturn to
PC: https://invisibleup.com/articles/24/

* Flat-Shaded Triangle Subroutine

** Convenient header

Just like the Hello GPU example.

#+begin_src asm
	.psx
	.create "trianglesub.bin", 0x80010000
	.org 0x80010000

	IO_BASE_ADDR equ 0x1f80
	GP0 equ 0x1810
	GP1 equ 0x1814

Main:
	; display setup
	lui	$t0, IO_BASE_ADDR
	li	$t1, 0x00000000	; 00 = reset gpu
	sw	$t1, GP1($t0)	; write packet to GP1
	li	$t1, 0x03000000	; 03 = Display enable
	sw	$t1, GP1($t0)
	li	$t1, 0x08000001 ; 08 = display mode (320x240, 15-bit, NTSC)
	sw	$t1, GP1($t0)
	li	$t1, 0x06c60260	; 06 = H display range
	sw	$t1, GP1($t0)
	li	$t1, 0x07042018	; 07 = V display range
	sw	$t1, GP1($t0)
	li	$t1, 0xe1000400	; E1 = Draw Mode Settings
	sw	$t1, GP0($t0)	; write packet to GP0
	li	$t1, 0xe3000000	; E3 = drawing area topleft
	sw	$t1, GP0($t0)
	li	$t1, 0xe403bd3f	; E4 = drawing area bottomright
	sw	$t1, GP0($t0)
	li	$t1, 0xe5000000	; E5 = drawing offset
	sw	$t1, GP0($t0)
#+end_src

** Creating the subroutine

We would like to perform draws to the GPU in such a way:

#+begin_src asm
	lui	$a0, IO_BASE_ADDR

	;;  Invoke subroutine to draw flat triangle
	li	$s0, 0xffff00	; Param: Color (0xBBGGRR)
	li	$s1, 200	; Param: x1
	li	$s2, 40		; Param: y1
	li	$s3, 288	; Param: x2
	li	$s4, 56		; Param: y2
	li	$s5, 224	; Param: x3
	li	$s6, 200	; Param: y3
	jal	DrawFlatTriangle
	nop
#+end_src

Here is a halt loop for convenience:

#+begin_src asm
Halt:
	j Halt
	nop
#+end_src

Normally,  according to  the  MIPS  ABI, we  have  to  send function  parameters
through  the ~$ax~  registers if  we can.  But in  this case,  we have  too many
arguments, so we don't have enough ~$ax~ registers for them.

The  ~$sx~  registers  are  originally  registers  that  should  persist  across
functions, but we're using them right now for convenience.

#+begin_src asm
	;; Subroutine to draw a flat-shaded triangle.
	;; Args:
	;; $a0 = IO_BASE_ADDR (IO ports at 0x1f80****)
	;; $s1 = x1
	;; $s2 = y1
	;; $s3 = x2
	;; $s4 = y2
	;; $s5 = x3
	;; $s6 = x3
DrawFlatTriangle:
#+end_src

** Initial setup

We start by  setting up and configuring  the comment and the  color. These masks
can be OR'd to be combined.

#+begin_src asm
	lui	$t0, 0x2000	; 0x20 = flat triangle
	or	$t1, $t0, $s0	; setup command+color on $t1
	sw	$t1, GP0($a0)	; write to GP0
#+end_src

** Writing X and Y coordinates of vertices

Here we need to merge X and Y into a single 32-bit mask. So we take y1, shift it
16 bits to the left;  then we AND x1 and ~0xffff~ so that  any extra bytes on x1
are discarded. Finally, combine it and send it to GP0.

#+begin_src asm
	sll	$s2, $s2, 16		; y1 = y1 << 16
	andi	$s1, $s1, 0xffff	; discard anything in x1 after two LSB
	or	$t1, $s1, $s2		; $t1 = x1 | y1 (at respective offsets)
	sw	$t1, GP0($a0)		; write vertex 1 to GP0
#+end_src

Now we do the same to vertices 2 and 3.

#+begin_src asm
	sll	$s4, $s4, 16
	andi	$s3, $s3, 0xffff
	or	$t1, $s3, $s4		; $t1 = x2 | y2 (at respective offsets)
	sw	$t1, GP0($a0)		; write vertex 2 to GP0

	sll	$s6, $s6, 16
	andi	$s5, $s5, 0xffff
	or	$t1, $s5, $s6		; $t1 = x3 | y3 (at respective offsets)
	sw	$t1, GP0($a0)		; write vertex 3 to GP0
#+end_src

** Finish function

Return to main.

#+begin_src asm
	jr	$ra
	nop
#+end_src

** End

#+begin_src asm
	.close
#+end_src

* Coding our Flat Triangle Subroutine

Instead of  copying and pasting  the subroutine  in the ~hellogpu.s~  project, I
created a new project  just for this routine. Just use Org  Babel to tangle this
file and it should be fine.

However, passing  parameters through ~$sx~ registers  is still a mistake.  If we
had many  parameters, eventually we  would exhaust  the amount of  registers. So
there is still a better way to send several parameters to subroutines like this:
the *stack*.

* Stack & Stack Pointer

